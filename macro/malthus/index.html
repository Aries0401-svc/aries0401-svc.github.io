<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>맬서스 트랩: 출생·사망률 vs 소득 & 소득 vs 인구 (v3.5)</title>

  <!-- 공통 폰트/스타일 (assets 참조) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />

  <!-- favicon 404 방지 -->
  <link rel="icon" href="data:," />

  <!-- D3.js (d3 미정의 방지: defer 사용 안 함) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

  <style>
    :root{ --bg:#0b1020; --panel:#121830; --text:#e8edf7; --muted:#9fb0d3; --accent:#6aa3ff; --accent2:#ff7a7a; --grid:#2a355d; --line:#1e2746; --good:#3bd07a; --warn:#ffb85c; }
    *{box-sizing:border-box}
    body{ margin:0; padding:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Noto Sans, Apple SD Gothic Neo, "맑은 고딕", sans-serif; background: var(--bg); color: var(--text); }
    header{ padding: 28px 20px 10px; max-width: 1100px; margin: 0 auto 6px auto; }
    h1{ font-size: clamp(20px, 3vw, 28px); margin:0 0 8px 0; font-weight: 700; }
    p.subtitle{ margin:0; color: var(--muted); line-height:1.5; }

    .controls{ max-width: 1100px; margin: 14px auto; padding: 12px 16px; border:1px solid var(--line); border-radius: 14px; background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.05)); display:grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; }
    .btn{ cursor:pointer; border:1px solid var(--line); background:#1a2446; color:#e8edf7; padding:10px 14px; border-radius:12px; font-weight:600; letter-spacing:.2px; }
    .btn:hover{ filter:brightness(1.1); }
    .btn.primary{ background:#23407a; border-color:#2a4e9b; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; filter:grayscale(.2); }

    .meter{ display:grid; grid-template-columns: repeat(7, auto); gap: 10px; align-items:center; }
    .meter .label{ color: var(--muted); font-weight: 600; }
    .chip{ padding:6px 10px; border-radius:10px; border:1px solid var(--line); background:#0f1630; font-size:12px; }
    .state{ display:inline-flex; align-items:center; gap:6px; }
    .dot{ width:8px; height:8px; border-radius:999px; display:inline-block; background:#7aa8ff; }
    .dot.ok{ background:#3bd07a; }

    .grid{ max-width: 1100px; margin: 12px auto 30px; padding: 0 0 6px 0; display:grid; gap: 16px; grid-template-columns: 1fr; }
    @media(min-width: 980px){ .grid{ grid-template-columns: 1fr 1fr; } }

    .card{ background: var(--panel); border:1px solid var(--line); border-radius: 16px; padding: 14px 14px 8px 14px; position: relative; box-shadow: 0 10px 22px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.02); }
    .card h2{ margin:0 0 6px 6px; font-size: 16px; letter-spacing:.2px; color: #d8e4ff; }
    .card .sub{ margin:0 0 4px 6px; font-size: 12px; color: var(--muted); }
    .chart{ width: 100%; height: 340px; }

    .axis path, .axis line{ stroke: #566; shape-rendering: crispEdges; }
    .gridline line{ stroke: var(--grid); }
    .gridline .domain{ display:none; }
    .series-birth{ stroke: var(--accent); fill: none; stroke-width: 2.5; }
    .series-death{ stroke: var(--accent2); fill: none; stroke-width: 2.5; }
    .series-income{ stroke: var(--good); fill: none; stroke-width: 2.5; }

    /* 가이드 */
    .current-line{ stroke:#e8edf7; stroke-width:2; stroke-dasharray:3 6; opacity:.95; }
    .eq0-line{ stroke: #9fb0d3; stroke-width:1.5; stroke-dasharray:2 4; opacity:.6; }
    .h-guide{ stroke:#e8edf7; stroke-width:1.6; stroke-dasharray:4 6; opacity:.9; }
    .equilibrium{ fill: #fff; stroke: #000; stroke-width: .6; }
    .eq1-dot{ fill: var(--warn); stroke:#000; stroke-width:.6; }

    /* 변경 전(점선) 스타일 */
    .prev-birth, .prev-death, .prev-income{ fill:none; stroke-width:2.5; stroke-dasharray:6 6; opacity:.65; }
    .prev-birth{ stroke: var(--accent); }
    .prev-death{ stroke: var(--accent2); }
    .prev-income{ stroke: var(--good); }

    .legend{ position:absolute; right: 12px; top: 10px; background: rgba(0,0,0,.25); border:1px solid var(--line); border-radius: 10px; padding: 6px 8px; display:flex; gap: 10px; align-items:center; }
    .legend span{ display:inline-flex; gap:6px; align-items:center; font-size:12px; color: var(--muted); }
    .legend i{ width:16px; height:3px; display:inline-block; border-radius: 999px; }

    .footer{ max-width:1100px; margin: 0 auto 30px; color: var(--muted); font-size: 12px; padding: 0 6px; }
    a{ color: #a9cbff; text-decoration: none; }
    a:hover{ text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <h1>맬서스 트랩 – 두 가지 핵심 그림 (v3.5)</h1>
    <p class="subtitle">각 시나리오에서 <em>곡선이 먼저 천천히 이동</em>하고, 이후 <em>N(t)</em>가 새 목표로 수렴합니다. 시나리오3(기술 진보)에서는 <em>수평 보조 점선</em>으로 <code>y*</code>가 같음을 표시합니다.</p>
  </header>

  <section class="controls" aria-label="시나리오 & 실시간 측정기">
    <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
      <button id="scenario1" class="btn primary">시나리오 1: 출생률 외생 증가</button>
      <button id="scenario2" class="btn primary">시나리오 2: 사망률 외생 증가</button>
      <button id="scenario3" class="btn primary">시나리오 3: 기술 진보</button>
      <button id="reset" class="btn">초기화</button>
    </div>
    <div class="meter">
      <span class="label">실시간</span>
      <span class="chip">N(t): <b id="mN">-</b></span>
      <span class="chip">y(t): <b id="mY">-</b></span>
      <span class="chip">b(y): <b id="mB">-</b>% · d(y): <b id="mD">-</b>%</span>
      <span class="chip state"><i class="dot" id="mDot"></i><span id="mState">대기</span></span>
      <span class="chip">y* (고정): <b id="mYStar0">-</b></span>
    </div>
  </section>

  <main class="grid">
    <!-- Chart 1: Birth & Death vs Income -->
    <section class="card" aria-label="소득에 따른 출생·사망률">
      <h2>출생률·사망률 vs 1인당 소득</h2>
      <p class="sub">가로축: 1인당 소득 (0–100) · 세로축: 연간 비율(%) — 흰 점선은 <em>현재 소득 y(t)</em>. 초기 교차점의 점(포인트)은 숨김, <span style="color:var(--warn)">노란 점</span>은 시나리오1·2에서 새 교차점 도달 시에만 표시. <strong>점선=변경 전 곡선</strong></p>
      <div id="chart1" class="chart" role="img" aria-label="소득에 따른 출생률과 사망률 곡선"></div>
      <div class="legend">
        <span><i style="background: var(--accent)"></i> 출생률</span>
        <span><i style="background: var(--accent2)"></i> 사망률</span>
      </div>
    </section>

    <!-- Chart 2: Income vs Population (downward, linear) -->
    <section class="card" aria-label="인구에 따른 1인당 소득">
      <h2>1인당 소득 vs 인구 (선형 우하향)</h2>
      <p class="sub">가로축: 인구 N (50–150) · 세로축: 1인당 소득 (0–100) — <span style="color:#cfd8ea">회색 점</span>은 <em>초기 균형</em>, <span style="color:#a9cbff">파란 점</span>은 <em>현재 상태</em>. 시나리오3에서 곡선 전체가 <em>상방 이동</em>. <strong>점선=변경 전 곡선</strong></p>
      <div id="chart2" class="chart" role="img" aria-label="인구와 1인당 소득의 선형 우하향 관계"></div>
      <div class="legend">
        <span><i style="background: var(--good)"></i> y(N) = a − s·N</span>
        <span><i style="background: #e8edf7"></i> y(t) (현재)</span>
      </div>
    </section>
  </main>

  <!-- 정보 풋노트 -->
  <div class="footer">
    <p>오른쪽 함수는 <code>y(N)=a-sN</code>이며, 시나리오3(기술 진보)에서는 <code>a</code>(절편)을 <strong>상향</strong> 이동시켜 모든 N에서 y를 높입니다. 출생/사망 곡선은 그대로라서 고정 균형 소득 <code>y* = y*₀</code>로 <em>재수렴</em>합니다.</p>
  </div>

  <!-- 네비게이션 풋터 (요청: 이전/처음 버튼) -->
  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
    <small>© <span id="year"></span> aries0401-svc</small>
  </footer>

  <!-- 공통 스크립트 -->
  <script src="../../assets/site.js"></script>

<script>
(function(){
  // ====== 공통 유틸 ======
  const clamp = (x,min,max)=> Math.max(min, Math.min(max, x));
  const fmt = (v, p=2)=> (Math.round(v * 10**p) / 10**p).toFixed(p);

  // ====== 모형 파라미터 (그래프 1) ======
  const birthBase = { b0: 1.5, b1: 2.5, k: 0.03 };   // [%/년]
  const deathBase = { dmin: 1.5, drop: 4.0, m: 0.04 }; // [%/년]

  let birthParams = {...birthBase};
  let deathParams = {...deathBase};
  const b = (y)=> birthParams.b0 + birthParams.b1 * (1 - Math.exp(-birthParams.k*y));
  const d = (y)=> deathParams.dmin + deathParams.drop * Math.exp(-deathParams.m*y);

  function findIncomeSteadyState(yMin=0, yMax=100, step=0.02){
    let bestY=yMin, bestGap=Infinity;
    for(let y=yMin; y<=yMax; y+=step){
      const gap = Math.abs(b(y) - d(y));
      if(gap < bestGap){ bestGap = gap; bestY = y; }
    }
    return bestY;
  }

  // ====== (선형) 소득-인구 ======
  const lin = { slope: 0.25, Nmin: 50, Nmax: 150, N0: 100 };
  let yStar0 = findIncomeSteadyState();
  let aIntercept = yStar0 + lin.slope * lin.N0;      // y(N0)=y*0 (초기)
  function yOfN(N){ return aIntercept - lin.slope * N; }
  function yOfNWith(a,N){ return a - lin.slope * N; }
  function findNstarWithA(a,y){ return (a - y) / lin.slope; }
  function findNstar(y){ return (aIntercept - y) / lin.slope; }

  // ====== 상태 ======
  let currentN = lin.N0;
  let targetN = lin.N0;
  let yStarNew = yStar0;           // 시나리오1·2에서만 다른 값으로 사용
  let timer = null;
  let scenarioActive = false;

  // ====== SVG 구성 ======
  const chart1El = document.getElementById('chart1');
  const chart2El = document.getElementById('chart2');
  function createSVG(container){
    const svg = d3.select(container).append('svg')
      .attr('viewBox', '0 0 640 360')
      .attr('preserveAspectRatio','xMidYMid meet')
      .style('width', '100%').style('height','100%');
    return svg;
  }

  // ====== 차트 1 ======
  const svg1 = createSVG(chart1El);
  const m1 = {t:18, r:14, b:36, l:48};
  const W1 = 640 - m1.l - m1.r, H1 = 360 - m1.t - m1.b;
  const g1 = svg1.append('g').attr('transform', `translate(${m1.l},${m1.t})`);
  const x1 = d3.scaleLinear().domain([0,100]).range([0,W1]);
  const y1 = d3.scaleLinear().domain([0,6.2]).range([H1,0]);

  g1.append('g').attr('class','gridline').attr('transform',`translate(0,${H1})`).call(d3.axisBottom(x1).tickSize(-H1).tickFormat(''));
  g1.append('g').attr('class','gridline').call(d3.axisLeft(y1).tickSize(-W1).tickFormat(''));
  g1.append('g').attr('class','axis').attr('transform',`translate(0,${H1})`).call(d3.axisBottom(x1));
  g1.append('g').attr('class','axis').call(d3.axisLeft(y1).ticks(6));

  const line1 = d3.line().x(d=>x1(d.x)).y(d=>y1(d.y)).curve(d3.curveMonotoneX);
  const xs = d3.range(0, 100.001, 0.5);

  // 변경 전(점선) 경로
  const prevBirthPath = g1.append('path').attr('class','prev-birth').style('opacity',0);
  const prevDeathPath = g1.append('path').attr('class','prev-death').style('opacity',0);

  // 현재 경로
  const birthPath = g1.append('path').attr('class','series-birth');
  const deathPath = g1.append('path').attr('class','series-death');
  const currentYLine = g1.append('line').attr('class','current-line');
  const eq0Line = g1.append('line').attr('class','eq0-line');
  const eq1Dot = g1.append('circle').attr('class','eq1-dot').attr('r', 5).style('opacity',0); // 새 교차점(시나리오1·2)

  g1.append('text').attr('x', W1/2).attr('y', H1+28).attr('text-anchor','middle').attr('fill','var(--muted)').text('1인당 소득');
  g1.append('text').attr('x', -H1/2).attr('y', -36).attr('transform','rotate(-90)')
    .attr('text-anchor','middle').attr('fill','var(--muted)').text('연간 비율(%)');

  function drawChart1(){
    const birthData = xs.map(x=>({x, y: b(x)}));
    const deathData = xs.map(x=>({x, y: d(x)}));
    birthPath.datum(birthData).attr('d', line1);
    deathPath.datum(deathData).attr('d', line1);

    // 초기 균형: 세로 점선만 유지
    eq0Line.attr('x1', x1(yStar0)).attr('x2', x1(yStar0)).attr('y1', 0).attr('y2', H1);

    // 현재 y(t) 세로선
    const yNow = yOfN(currentN);
    currentYLine.attr('x1', x1(yNow)).attr('x2', x1(yNow)).attr('y1', 0).attr('y2', H1);

    // 새 교차점(노란 점) 위치 갱신(표시는 시나리오1·2 완료 시)
    eq1Dot.attr('cx', x1(yStarNew)).attr('cy', y1(b(yStarNew)));
  }

  // ====== 차트 2 ======
  const svg2 = createSVG(chart2El);
  const m2 = {t:18, r:14, b:36, l:48};
  const W2 = 640 - m2.l - m2.r, H2 = 360 - m2.t - m2.b;
  const g2 = svg2.append('g').attr('transform', `translate(${m2.l},${m2.t})`);
  const x2 = d3.scaleLinear().domain([lin.Nmin, lin.Nmax]).range([0,W2]);
  const y2 = d3.scaleLinear().domain([0,100]).range([H2,0]);

  g2.append('g').attr('class','gridline').attr('transform',`translate(0,${H2})`).call(d3.axisBottom(x2).tickSize(-H2).tickFormat(''));
  g2.append('g').attr('class','gridline').call(d3.axisLeft(y2).tickSize(-W2).tickFormat(''));
  g2.append('g').attr('class','axis').attr('transform',`translate(0,${H2})`).call(d3.axisBottom(x2));
  g2.append('g').attr('class','axis').call(d3.axisLeft(y2));

  const line2 = d3.line().x(d=>x2(d.N)).y(d=>y2(d.y)).curve(d3.curveLinear);
  // 변경 전(점선) 경로
  const prevIncomePath = g2.append('path').attr('class','prev-income').style('opacity',0);
  // 현재 경로
  const curve2Path = g2.append('path').attr('class','series-income');
  const eq0DotR = g2.append('circle').attr('class','equilibrium').attr('r',4.5).style('fill','#cfd8ea'); // 오른쪽 초기 균형(회색)
  const statePt = g2.append('circle').attr('class','equilibrium').attr('r',5).style('fill','var(--accent)');
  const yStarGuide = g2.append('line').attr('class','h-guide').style('opacity',0); // 시나리오3용 수평 보조선

  g2.append('text').attr('x', W2/2).attr('y', H2+28).attr('text-anchor','middle').attr('fill','var(--muted)').text('인구 N');
  g2.append('text').attr('x', -H2/2).attr('y', -36).attr('transform','rotate(-90)')
    .attr('text-anchor','middle').attr('fill','var(--muted)').text('1인당 소득');

  function drawChart2(){
    const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
    const data = Ns.map(N=> ({N, y: yOfN(N)}));
    curve2Path.datum(data).attr('d', line2);

    const yNow = yOfN(currentN);
    statePt.attr('cx', x2(currentN)).attr('cy', y2(yNow));

    // 초기 균형점(오른쪽) – 고정
    eq0DotR.attr('cx', x2(lin.N0)).attr('cy', y2(yStar0));

    // 시나리오3 보조선 (y = y*0)
    yStarGuide.attr('x1', 0).attr('x2', W2).attr('y1', y2(yStar0)).attr('y2', y2(yStar0));

    g2.selectAll('.n-label').data([currentN]).join('text')
      .attr('class','n-label')
      .attr('x', d => x2(d)+6)
      .attr('y', d => y2(yOfN(d)) - 8)
      .attr('fill', 'var(--muted)')
      .attr('font-size', 11)
      .text(d => `N(t) ≈ ${fmt(d,1)}, y(t) ≈ ${fmt(yOfN(d),1)}`);
  }

  // ====== 측정기 ======
  const mN = document.getElementById('mN');
  const mY = document.getElementById('mY');
  const mB = document.getElementById('mB');
  const mD = document.getElementById('mD');
  const mState = document.getElementById('mState');
  const mDot = document.getElementById('mDot');
  const mYStar0 = document.getElementById('mYStar0');

  function updateMeter(){
    const yNow = yOfN(currentN);
    const by = b(yNow), dy = d(yNow), g = by - dy;
    mN.textContent = fmt(currentN,1);
    mY.textContent = fmt(yNow,1);
    mB.textContent = fmt(by,2);
    mD.textContent = fmt(dy,2);
    mYStar0.textContent = fmt(yStar0,1);

    const delta = Math.abs(targetN - currentN);
    if(delta < 0.02){
      mState.textContent = '균형 도달';
      mDot.classList.add('ok');
    } else {
      mState.textContent = (g >= 0 ? '진행 중: 인구 ↑' : '진행 중: 인구 ↓');
      mDot.classList.remove('ok');
    }
  }

  // ====== 초기 렌더 ======
  function renderAll(){ drawChart1(); drawChart2(); updateMeter(); }
  renderAll();

  // ====== 시나리오 실행 공통 함수 ======
  const scenario1Btn = document.getElementById('scenario1');
  const scenario2Btn = document.getElementById('scenario2');
  const scenario3Btn = document.getElementById('scenario3');
  const resetBtn = document.getElementById('reset');

  function runToTarget({showEqDot=true}={}){
    if(timer) timer.stop();
    let last = performance.now();
    const speed = 0.35; // 완만하지만 끝이 보이게
    const eps = 0.05;   // 스냅 임계값
    timer = d3.timer(()=>{
      const now = performance.now();
      const dt = Math.min(0.05, (now - last)/1000);
      last = now;
      currentN += speed * dt * (targetN - currentN);
      if(Math.abs(targetN - currentN) < eps){
        currentN = targetN;
        timer.stop();
        if(showEqDot){ d3.select(eq1Dot.node()).transition().duration(250).style('opacity',1); }
      }
      renderAll();
    });
  }

  function lockScenarios(){
    scenarioActive = true;
    scenario1Btn.disabled = true;
    scenario2Btn.disabled = true;
    scenario3Btn.disabled = true;
  }

  // 시나리오 1: 출생률 외생 증가 (출생률 곡선 상방 이동 → y*↓, N*↑)
  function startScenario1(){
    if(scenarioActive) return; lockScenarios();

    // 변경 전 곡선(점선) 저장
    const birthDataOld = xs.map(x=>({x, y: b(x)}));
    prevBirthPath.datum(birthDataOld).attr('d', line1).style('opacity',.65);

    // 새 파라미터 적용
    birthParams = {...birthParams, b0: birthParams.b0 + 0.6};
    yStarNew = findIncomeSteadyState();
    targetN = clamp(findNstar(yStarNew), lin.Nmin, lin.Nmax);

    const birthDataNew = xs.map(x=>({x, y: b(x)}));
    birthPath
      .datum(birthDataNew)
      .transition().duration(1200).ease(d3.easeCubicInOut)
      .attr('d', line1)
      .on('end', ()=> runToTarget({showEqDot:true})); // 곡선 이동 후 N 수렴 시작
  }

  // 시나리오 2: 사망률 외생 증가 (사망률 곡선 상방 이동 → y*↑, N*↓)
  function startScenario2(){
    if(scenarioActive) return; lockScenarios();

    // 변경 전 곡선(점선) 저장
    const deathDataOld = xs.map(x=>({x, y: d(x)}));
    prevDeathPath.datum(deathDataOld).attr('d', line1).style('opacity',.65);

    // 새 파라미터 적용
    deathParams = {...deathParams, dmin: deathParams.dmin + 0.6};
    yStarNew = findIncomeSteadyState();
    targetN = clamp(findNstar(yStarNew), lin.Nmin, lin.Nmax);

    const deathDataNew = xs.map(x=>({x, y: d(x)}));
    deathPath
      .datum(deathDataNew)
      .transition().duration(1200).ease(d3.easeCubicInOut)
      .attr('d', line1)
      .on('end', ()=> runToTarget({showEqDot:true}));
  }

  // 시나리오 3: 기술 진보 (y(N) 상방 이동 → 초기엔 y↑, b>d → N↑ → y가 y*로 회귀)
  function startScenario3(){
    if(scenarioActive) return; lockScenarios();

    // 변경 전 곡선(점선) 저장
    const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
    const dataOld = Ns.map(N=> ({N, y: yOfN(N)}));
    prevIncomePath.datum(dataOld).attr('d', line2).style('opacity',.65);

    // 기술 충격: 절편 a 상향 (단, 곡선 애니메이션이 끝날 때까지 전역 aIntercept는 보류)
    const techBoost = 8;
    const aNew = aIntercept + techBoost;

    // 새 곡선 데이터(전역 반영 전)
    const dataNew = Ns.map(N=> ({N, y: yOfNWith(aNew,N)}));

    // 수평 보조선 표시
    d3.select(yStarGuide.node()).transition().duration(400).style('opacity',1);

    // 곡선 먼저 천천히 이동
    d3.select(curve2Path.node())
      .datum(dataNew)
      .transition().duration(1200).ease(d3.easeCubicInOut)
      .attr('d', line2)
      .on('end', ()=>{
        // 이제 전역 aIntercept를 갱신하고, N을 y*로 돌려보냄
        aIntercept = aNew;
        targetN = clamp(findNstarWithA(aIntercept, yStar0), lin.Nmin, lin.Nmax);
        // 노란 점 비활성(이 케이스는 y* 고정 회귀)
        d3.select(eq1Dot.node()).style('opacity',0);
        runToTarget({showEqDot:false});
      });
  }

  function resetAll(){
    if(timer) timer.stop();
    birthParams = {...birthBase};
    deathParams = {...deathBase};
    yStar0 = findIncomeSteadyState();
    yStarNew = yStar0;
    aIntercept = yStar0 + lin.slope * lin.N0; // 기술 이전 상태로 복원
    currentN = lin.N0;
    targetN = currentN;

    d3.select(eq1Dot.node()).style('opacity',0);
    scenarioActive = false;
    scenario1Btn.disabled = false;
    scenario2Btn.disabled = false;
    scenario3Btn.disabled = false;

    // 곡선 원복
    const birthDataBase = xs.map(x=>({x, y: b(x)}));
    const deathDataBase = xs.map(x=>({x, y: d(x)}));
    birthPath.datum(birthDataBase).attr('d', line1);
    deathPath.datum(deathDataBase).attr('d', line1);

    const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
    const dataBase = Ns.map(N=> ({N, y: yOfN(N)}));
    d3.select(curve2Path.node()).datum(dataBase).attr('d', line2);

    // 점선/보조선 숨김
    prevBirthPath.style('opacity',0);
    prevDeathPath.style('opacity',0);
    prevIncomePath.style('opacity',0);
    d3.select(yStarGuide.node()).style('opacity',0);

    renderAll();
  }

  scenario1Btn.addEventListener('click', startScenario1);
  scenario2Btn.addEventListener('click', startScenario2);
  scenario3Btn.addEventListener('click', startScenario3);
  resetBtn.addEventListener('click', resetAll);
})();
</script>
</body>
</html>
