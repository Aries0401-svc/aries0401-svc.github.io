<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>맬서스 트랩</title>

  <!-- 에셋: 폰트/스타일 그대로 사용 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />

  <!-- favicon 404 방지 -->
  <link rel="icon" href="data:," />

  <!-- D3.js -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

  <style>
    /* 이 페이지 전용 최소 스타일 (에셋 규칙과 충돌/재정의 최소화) */

    /* 컨트롤 영역: 버튼 행(수평) + 그 아래에 미터 */
    .controls{
      width: min(100%, 1000px);
      margin: 14px auto;
      padding: 12px 16px;
      border:1px solid #223055; /* 불투명 테두리 */
      border-radius: 14px;
      /* 불투명 배경으로 변경 */
      background: linear-gradient(180deg, #0f172a, #0b1220);
      display:grid; 
      grid-template-columns: 1fr; /* 버튼행 위, 미터 아래 */
      gap: 12px;
      align-items: start;
    }
    @media (prefers-color-scheme: light){
      .controls{ 
        border-color: #cbd5e1;               /* 라이트 모드 테두리 */
        background: linear-gradient(180deg, #ffffff, #f3f4f6); /* 불투명 배경 */
      }
    }
    .actions{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .btn{
      cursor:pointer; border:1px solid rgba(255,255,255,.06);
      background:#1a2446; color: var(--text);
      padding:10px 14px; border-radius:12px; font-weight:600; letter-spacing:.2px;
    }
    @media (prefers-color-scheme: light){
      .btn{ border-color: rgba(2,6,23,.12); }
    }
    .btn.primary{ background:#23407a; border-color:#2a4e9b; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; filter:grayscale(.2); }

    .meter{ display:grid; grid-template-columns: repeat(6, auto); gap: 10px; align-items:center; }
    /* "실시간" 라벨 삭제에 맞춰 6칸으로 조정 */
    .chip{
      padding:6px 10px; border-radius:10px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.2);
      font-size:12px;
    }
    @media (prefers-color-scheme: light){
      .chip{ border-color: rgba(2,6,23,.12); background: rgba(2,6,23,.03); }
    }
    .state{ display:inline-flex; align-items:center; gap:6px; }
    .dot{ width:8px; height:8px; border-radius:999px; display:inline-block; background: var(--primary); }
    .dot.ok{ background:#22c55e; }

    /* 메인 그리드: 이 페이지만 2열(차트 2개) */
    .two-col{ grid-template-columns: 1fr; }
    @media(min-width: 980px){ .two-col{ grid-template-columns: 1fr 1fr; } }

    /* 카드 내부(차트) */
    .card h2{ margin:0 0 8px; }
    .card .sub{ margin:0 0 8px; color: var(--muted); font-size: 12px; }
    .chart{ width: 100%; height: 340px; }

    /* SVG 축/그리드/시리즈 */
    .axis path, .axis line{ stroke: var(--muted); opacity:.6; shape-rendering: crispEdges; }
    .gridline line{ stroke: rgba(148,163,184,.2); }
    .gridline .domain{ display:none; }
    .series-birth{ stroke: var(--primary); fill: none; stroke-width: 2.5; }
    .series-death{ stroke: #ef4444; fill: none; stroke-width: 2.5; }
    .series-income{ stroke: #22c55e; fill: none; stroke-width: 2.5; }

    /* 가이드 */
    .current-line{ stroke: var(--text); stroke-width:2; stroke-dasharray:3 6; opacity:.95; }
    .eq0-line{ stroke: var(--muted); stroke-width:1.5; stroke-dasharray:2 4; opacity:.6; }
    .h-guide{ stroke: var(--text); stroke-width:1.6; stroke-dasharray:4 6; opacity:.9; }
    .equilibrium{ fill: #fff; stroke: #000; stroke-width: .6; }
    .eq1-dot{ fill: #ffb85c; stroke:#000; stroke-width:.6; }

    /* 변경 전(점선) 스타일 */
    .prev-birth, .prev-death, .prev-income{ fill:none; stroke-width:2.5; stroke-dasharray:6 6; opacity:.65; }
    .prev-birth{ stroke: var(--primary); }
    .prev-death{ stroke: #ef4444; }
    .prev-income{ stroke: #22c55e; }

    .legend{
      position:absolute; right: 12px; top: 10px;
      background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.06);
      border-radius: 10px; padding: 6px 8px; display:flex; gap: 10px; align-items:center;
    }
    @media (prefers-color-scheme: light){
      .legend{ border-color: rgba(2,6,23,.12); background: rgba(0,0,0,.05); }
    }
    .legend span{ display:inline-flex; gap:6px; align-items:center; font-size:12px; color: var(--muted); }
    .legend i{ width:16px; height:3px; display:inline-block; border-radius: 999px; }
  </style>
</head>
<body>
  <!-- ⭐ 별 애니메이션 제거: #starfield 캔버스를 포함하지 않음 -->

  <!-- 에셋의 헤더 스타일을 그대로 사용. 부제(설명)는 요청에 따라 삭제 -->
  <header class="site-header">
    <h1>맬서스 트랩</h1>
  </header>

  <!-- 컨트롤: 버튼 행(수평) + 아래에 미터 -->
  <section class="controls" aria-label="시나리오 선택 및 상태">
    <div class="actions">
      <button id="scenario1" class="btn primary">시나리오 1: 출생률 외생 증가</button>
      <button id="scenario2" class="btn primary">시나리오 2: 사망률 외생 증가</button>
      <button id="scenario3" class="btn primary">시나리오 3: 기술 진보</button>
      <button id="reset" class="btn">초기화</button>
    </div>
    <div class="meter" aria-label="실시간 상태">
      <!-- "실시간" 라벨 삭제 -->
      <span class="chip">N(t): <b id="mN">-</b></span>
      <span class="chip">y(t): <b id="mY">-</b></span>
      <span class="chip">b(y): <b id="mB">-</b>%</span>
      <span class="chip">d(y): <b id="mD">-</b>%</span>
      <span class="chip state"><i class="dot" id="mDot"></i><span id="mState">대기</span></span>
      <span class="chip">y* (고정): <b id="mYStar0">-</b></span>
    </div>
  </section>

  <!-- 메인: 차트 2개 (2열) -->
  <main class="grid two-col">
    <!-- Chart 1 -->
    <section class="card" aria-label="소득에 따른 출생·사망률">
      <h2>출생률·사망률 vs 1인당 소득</h2>
      <div id="chart1" class="chart" role="img" aria-label="소득에 따른 출생률과 사망률 곡선"></div>
      <div class="legend">
        <span><i style="background: var(--primary)"></i> 출생률</span>
        <span><i style="background: #ef4444"></i> 사망률</span>
      </div>
    </section>

    <!-- Chart 2 -->
    <section class="card" aria-label="인구에 따른 1인당 소득">
      <h2>1인당 소득 vs 인구 (선형 우하향)</h2>
      <div id="chart2" class="chart" role="img" aria-label="인구와 1인당 소득의 선형 우하향 관계"></div>
      <div class="legend">
        <span><i style="background: #22c55e"></i> y(N) = a − s·N</span>
        <span><i style="width:10px;height:10px;border-radius:999px;background: var(--primary)"></i> y(t) (현재)</span>
      </div>
    </section>
  </main>

  <!-- 정보 풋노트: 요청에 따라 삭제(없음) -->

  <!-- 네비게이션 풋터: 예시와 동일 사이즈(12px 18px)로 정확히 맞춤 -->
  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
    <div style="margin-top:10px;"><small>© <span id="year"></span> aries0401-svc</small></div>
  </footer>

  <!-- 공통 스크립트(키보드 인터랙션 등). 별 애니메이션은 #starfield가 없어서 실행 안 됨 -->
  <script src="../../assets/site.js"></script>

<script>
(function(){
  // ====== 공통 유틸 ======
  const clamp = (x,min,max)=> Math.max(min, Math.min(max, x));
  const fmt = (v, p=2)=> (Math.round(v * 10**p) / 10**p).toFixed(p);

  // ====== 모형 파라미터 (그래프 1) ======
  const birthBase = { b0: 1.5, b1: 2.5, k: 0.03 };   // [%/년]
  const deathBase = { dmin: 1.5, drop: 4.0, m: 0.04 }; // [%/년]

  let birthParams = {...birthBase};
  let deathParams = {...deathBase};
  const b = (y)=> birthParams.b0 + birthParams.b1 * (1 - Math.exp(-birthParams.k*y));
  const d = (y)=> deathParams.dmin + deathParams.drop * Math.exp(-deathParams.m*y);

  function findIncomeSteadyState(yMin=0, yMax=100, step=0.02){
    let bestY=yMin, bestGap=Infinity;
    for(let y=yMin; y<=yMax; y+=step){
      const gap = Math.abs(b(y) - d(y));
      if(gap < bestGap){ bestGap = gap; bestY = y; }
    }
    return bestY;
  }

  // ====== (선형) 소득-인구 ======
  const lin = { slope: 0.25, Nmin: 50, Nmax: 150, N0: 100 };
  let yStar0 = findIncomeSteadyState();
  let aIntercept = yStar0 + lin.slope * lin.N0;      // y(N0)=y*0 (초기)
  function yOfN(N){ return aIntercept - lin.slope * N; }
  function yOfNWith(a,N){ return a - lin.slope * N; }
  function findNstarWithA(a,y){ return (a - y) / lin.slope; }
  function findNstar(y){ return (aIntercept - y) / lin.slope; }

  // ====== 상태 ======
  let currentN = lin.N0;
  let targetN = lin.N0;
  let yStarNew = yStar0;           // 시나리오1·2에서만 다른 값으로 사용
  let timer = null;
  let scenarioActive = false;

  // ====== SVG 구성 ======
  const chart1El = document.getElementById('chart1');
  const chart2El = document.getElementById('chart2');
  function createSVG(container){
    const svg = d3.select(container).append('svg')
      .attr('viewBox', '0 0 640 360')
      .attr('preserveAspectRatio','xMidYMid meet')
      .style('width', '100%').style('height','100%');
    return svg;
  }

  // ====== 차트 1 ======
  const svg1 = createSVG(chart1El);
  const m1 = {t:18, r:14, b:36, l:48};
  const W1 = 640 - m1.l - m1.r, H1 = 360 - m1.t - m1.b;
  const g1 = svg1.append('g').attr('transform', `translate(${m1.l},${m1.t})`);
  const x1 = d3.scaleLinear().domain([0,100]).range([0,W1]);
  const y1 = d3.scaleLinear().domain([0,6.2]).range([H1,0]);

  g1.append('g').attr('class','gridline').attr('transform',`translate(0,${H1})`).call(d3.axisBottom(x1).tickSize(-H1).tickFormat(''));
  g1.append('g').attr('class','gridline').call(d3.axisLeft(y1).tickSize(-W1).tickFormat(''));
  g1.append('g').attr('class','axis').attr('transform',`translate(0,${H1})`).call(d3.axisBottom(x1));
  g1.append('g').attr('class','axis').call(d3.axisLeft(y1).ticks(6));

  const line1 = d3.line().x(d=>x1(d.x)).y(d=>y1(d.y)).curve(d3.curveMonotoneX);
  const xs = d3.range(0, 100.001, 0.5);

  // 변경 전(점선) 경로
  const prevBirthPath = g1.append('path').attr('class','prev-birth').style('opacity',0);
  const prevDeathPath = g1.append('path').attr('class','prev-death').style('opacity',0);

  // 현재 경로
  const birthPath = g1.append('path').attr('class','series-birth');
  const deathPath = g1.append('path').attr('class','series-death');
  const currentYLine = g1.append('line').attr('class','current-line');
  const eq0Line = g1.append('line').attr('class','eq0-line');
  const eq1Dot = g1.append('circle').attr('class','eq1-dot').attr('r', 5).style('opacity',0); // 새 교차점(시나리오1·2)

  g1.append('text').attr('x', W1/2).attr('y', H1+28).attr('text-anchor','middle').attr('fill','var(--muted)').text('1인당 소득');
  g1.append('text').attr('x', -H1/2).attr('y', -36).attr('transform','rotate(-90)')
    .attr('text-anchor','middle').attr('fill','var(--muted)').text('연간 비율(%)');

  function drawChart1(){
    const birthData = xs.map(x=>({x, y: b(x)}));
    const deathData = xs.map(x=>({x, y: d(x)}));
    birthPath.datum(birthData).attr('d', line1);
    deathPath.datum(deathData).attr('d', line1);

    // 초기 균형: 세로 점선만 유지
    eq0Line.attr('x1', x1(yStar0)).attr('x2', x1(yStar0)).attr('y1', 0).attr('y2', H1);

    // 현재 y(t) 세로선
    const yNow = yOfN(currentN);
    currentYLine.attr('x1', x1(yNow)).attr('x2', x1(yNow)).attr('y1', 0).attr('y2', H1);

    // 새 교차점(노란 점) 위치 갱신(표시는 시나리오1·2 완료 시)
    eq1Dot.attr('cx', x1(yStarNew)).attr('cy', y1(b(yStarNew)));
  }

  // ====== 차트 2 ======
  const svg2 = createSVG(chart2El);
  const m2 = {t:18, r:14, b:36, l:48};
  const W2 = 640 - m2.l - m2.r, H2 = 360 - m2.t - m2.b;
  const g2 = svg2.append('g').attr('transform', `translate(${m2.l},${m2.t})`);
  const x2 = d3.scaleLinear().domain([lin.Nmin, lin.Nmax]).range([0,W2]);
  const y2 = d3.scaleLinear().domain([0,100]).range([H2,0]);

  g2.append('g').attr('class','gridline').attr('transform',`translate(0,${H2})`).call(d3.axisBottom(x2).tickSize(-H2).tickFormat(''));
  g2.append('g').attr('class','gridline').call(d3.axisLeft(y2).tickSize(-W2).tickFormat(''));
  g2.append('g').attr('class','axis').attr('transform',`translate(0,${H2})`).call(d3.axisBottom(x2));
  g2.append('g').attr('class','axis').call(d3.axisLeft(y2));

  const line2 = d3.line().x(d=>x2(d.N)).y(d=>y2(d.y)).curve(d3.curveLinear);
  // 변경 전(점선) 경로
  const prevIncomePath = g2.append('path').attr('class','prev-income').style('opacity',0);
  // 현재 경로
  const curve2Path = g2.append('path').attr('class','series-income');
  const eq0DotR = g2.append('circle').attr('class','equilibrium').attr('r',4.5).style('fill','#cfd8ea'); // 초기 균형(회색)
  const statePt = g2.append('circle').attr('class','equilibrium').attr('r',5).style('fill','var(--primary)');
  const yStarGuide = g2.append('line').attr('class','h-guide').style('opacity',0); // 시나리오3용 수평 보조선

  g2.append('text').attr('x', W2/2).attr('y', H2+28).attr('text-anchor','middle').attr('fill','var(--muted)').text('인구 N');
  g2.append('text').attr('x', -H2/2).attr('y', -36).attr('transform','rotate(-90)')
    .attr('text-anchor','middle').attr('fill','var(--muted)').text('1인당 소득');

  function drawChart2(){
    const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
    const data = Ns.map(N=> ({N, y: yOfN(N)}));
    curve2Path.datum(data).attr('d', line2);

    const yNow = yOfN(currentN);
    statePt.attr('cx', x2(currentN)).attr('cy', y2(yNow));

    // 초기 균형점 – 고정
    eq0DotR.attr('cx', x2(lin.N0)).attr('cy', y2(yStar0));

    // 시나리오3 보조선 (y = y*0)
    yStarGuide.attr('x1', 0).attr('x2', W2).attr('y1', y2(yStar0)).attr('y2', y2(yStar0));

    g2.selectAll('.n-label').data([currentN]).join('text')
      .attr('class','n-label')
      .attr('x', d => x2(d)+6)
      .attr('y', d => y2(yOfN(d)) - 8)
      .attr('fill', 'var(--muted)')
      .attr('font-size', 11)
      .text(d => `N(t) ≈ ${fmt(d,1)}, y(t) ≈ ${fmt(yOfN(d),1)}`);
  }

  // ====== 측정기 ======
  const mN = document.getElementById('mN');
  const mY = document.getElementById('mY');
  const mB = document.getElementById('mB');
  const mD = document.getElementById('mD');
  const mState = document.getElementById('mState');
  const mDot = document.getElementById('mDot');
  const mYStar0 = document.getElementById('mYStar0');

  function updateMeter(){
    const yNow = yOfN(currentN);
    const by = b(yNow), dy = d(yNow), g = by - dy;
    mN.textContent = fmt(currentN,1);
    mY.textContent = fmt(yNow,1);
    mB.textContent = fmt(by,2);
    mD.textContent = fmt(dy,2);
    mYStar0.textContent = fmt(yStar0,1);

    const delta = Math.abs(targetN - currentN);
    if(delta < 0.02){
      mState.textContent = '균형 도달';
      mDot.classList.add('ok');
    } else {
      mState.textContent = (g >= 0 ? '진행 중: 인구 ↑' : '진행 중: 인구 ↓');
      mDot.classList.remove('ok');
    }
  }

  // ====== 초기 렌더 ======
  function renderAll(){ drawChart1(); drawChart2(); updateMeter(); }
  renderAll();

  // ====== 시나리오 실행 공통 함수 ======
  const scenario1Btn = document.getElementById('scenario1');
  const scenario2Btn = document.getElementById('scenario2');
  const scenario3Btn = document.getElementById('scenario3');
  const resetBtn = document.getElementById('reset');

  function runToTarget({showEqDot=true}={}){
    if(timer) timer.stop();
    let last = performance.now();
    const speed = 0.35; // 완만하지만 끝이 보이게
    const eps = 0.05;   // 스냅 임계값
    timer = d3.timer(()=>{
      const now = performance.now();
      const dt = Math.min(0.05, (now - last)/1000);
      last = now;
      currentN += speed * dt * (targetN - currentN);
      if(Math.abs(targetN - currentN) < eps){
        currentN = targetN;
        timer.stop();
        if(showEqDot){ d3.select(eq1Dot.node()).transition().duration(250).style('opacity',1); }
      }
      renderAll();
    });
  }

  function lockScenarios(){
    scenarioActive = true;
    scenario1Btn.disabled = true;
    scenario2Btn.disabled = true;
    scenario3Btn.disabled = true;
  }

  // 시나리오 1
  function startScenario1(){
    if(scenarioActive) return; lockScenarios();

    const birthDataOld = d3.range(0,100.001,0.5).map(x=>({x, y: b(x)}));
    prevBirthPath.datum(birthDataOld).attr('d', line1).style('opacity',.65);

    birthParams = {...birthParams, b0: birthParams.b0 + 0.6};
    yStarNew = findIncomeSteadyState();
    targetN = clamp(findNstar(yStarNew), lin.Nmin, lin.Nmax);

    const birthDataNew = d3.range(0,100.001,0.5).map(x=>({x, y: b(x)}));
    birthPath
      .datum(birthDataNew)
      .transition().duration(1200).ease(d3.easeCubicInOut)
      .attr('d', line1)
      .on('end', ()=> runToTarget({showEqDot:true}));
  }

  // 시나리오 2
  function startScenario2(){
    if(scenarioActive) return; lockScenarios();

    const deathDataOld = d3.range(0,100.001,0.5).map(x=>({x, y: d(x)}));
    prevDeathPath.datum(deathDataOld).attr('d', line1).style('opacity',.65);

    deathParams = {...deathParams, dmin: deathParams.dmin + 0.6};
    yStarNew = findIncomeSteadyState();
    targetN = clamp(findNstar(yStarNew), lin.Nmin, lin.Nmax);

    const deathDataNew = d3.range(0,100.001,0.5).map(x=>({x, y: d(x)}));
    deathPath
      .datum(deathDataNew)
      .transition().duration(1200).ease(d3.easeCubicInOut)
      .attr('d', line1)
      .on('end', ()=> runToTarget({showEqDot:true}));
  }

  // 시나리오 3
  function startScenario3(){
    if(scenarioActive) return; lockScenarios();

    const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
    const dataOld = Ns.map(N=> ({N, y: yOfN(N)}));
    prevIncomePath.datum(dataOld).attr('d', line2).style('opacity',.65);

    const techBoost = 8;
    const aNew = aIntercept + techBoost;
    const dataNew = Ns.map(N=> ({N, y: yOfNWith(aNew,N)}));

    d3.select(yStarGuide.node()).transition().duration(400).style('opacity',1);

    d3.select(curve2Path.node())
      .datum(dataNew)
      .transition().duration(1200).ease(d3.easeCubicInOut)
      .attr('d', line2)
      .on('end', ()=>{
        aIntercept = aNew;
        targetN = clamp(findNstarWithA(aIntercept, yStar0), lin.Nmin, lin.Nmax);
        d3.select(eq1Dot.node()).style('opacity',0);
        runToTarget({showEqDot:false});
      });
  }

  function resetAll(){
    if(timer) timer.stop();
    birthParams = {...birthBase};
    deathParams = {...deathBase};
    yStar0 = findIncomeSteadyState();
    yStarNew = yStar0;
    aIntercept = yStar0 + lin.slope * lin.N0;
    currentN = lin.N0;
    targetN = currentN;

    d3.select(eq1Dot.node()).style('opacity',0);
    scenarioActive = false;
    scenario1Btn.disabled = false;
    scenario2Btn.disabled = false;
    scenario3Btn.disabled = false;

    const xs = d3.range(0,100.001,0.5);
    birthPath.datum(xs.map(x=>({x, y: b(x)}))).attr('d', line1);
    deathPath.datum(xs.map(x=>({x, y: d(x)}))).attr('d', line1);

    const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
    d3.select(curve2Path.node()).datum(Ns.map(N=> ({N, y: yOfN(N)}))).attr('d', line2);

    prevBirthPath.style('opacity',0);
    prevDeathPath.style('opacity',0);
    prevIncomePath.style('opacity',0);
    d3.select(yStarGuide.node()).style('opacity',0);

    renderAll();
  }

  scenario1Btn.addEventListener('click', startScenario1);
  scenario2Btn.addEventListener('click', startScenario2);
  scenario3Btn.addEventListener('click', startScenario3);
  resetBtn.addEventListener('click', resetAll);
})();
</script>
</body>
</html>
