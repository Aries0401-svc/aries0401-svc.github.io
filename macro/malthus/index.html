<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>맬서스 트랩: 출생·사망률 vs 소득 · 소득 vs 인구</title>
  <meta name="description" content="맬서스 모형의 핵심 메커니즘을 두 개의 인터랙티브 차트로 시각화합니다: (1) 소득에 따른 출생·사망률, (2) 인구에 따른 1인당 소득. 세 가지 시나리오(출생률 증가, 사망률 증가, 기술 진보)를 버튼으로 재생하세요." />

  <!-- 공통 스타일/폰트: 프로젝트 assets 참조 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />

  <!-- D3 (버전 고정) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7" defer></script>

  <style>
    /* ─────────────────────────────────────────────────────────────────────────
       페이지 전용 스타일 (프로젝트 토큰과 일치)
       - 색상은 가급적 assets/style.css의 CSS 변수 사용
       - 필요한 최소 보조 변수만 정의
       ───────────────────────────────────────────────────────────────────────── */
    :root{
      /* 프로젝트 공통 토큰을 최대한 재사용 (fallback 포함) */
      --accent: var(--primary, #6aa3ff);
      --accent2: var(--danger, #ff7a7a);
      --good: var(--positive, #3bd07a);
      --grid: color-mix(in oklab, var(--muted) 32%, transparent);
      --line: color-mix(in oklab, var(--muted) 40%, transparent);
    }

    /* 레이아웃 */
    main.grid { grid-template-columns: 1fr; gap: 1rem; }
    @media (min-width: 980px){ main.grid { grid-template-columns: 1fr 1fr; } }
    .chart-wrap{ position:relative; height:360px; }

    /* 컨트롤 카드의 버튼/칩 스타일은 다른 페이지와 맞춤 */
    .controls { display:flex; flex-direction:column; gap:.75rem; }
    .controls .row { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .controls button{
      border:1px solid var(--muted);
      background:var(--panel);
      color:var(--text);
      padding:.5rem .75rem;
      border-radius:.5rem;
      box-shadow: var(--shadow);
      font:inherit;
      cursor:pointer;
    }
    .controls button:disabled{ opacity:.6; cursor:not-allowed; }
    .controls button.primary{ border-color: color-mix(in oklab, var(--primary) 50%, var(--muted)); background: color-mix(in oklab, var(--panel) 70%, var(--primary)); }
    .controls button:focus-visible{ outline:0; box-shadow:0 0 0 4px var(--ring); }

    .meter { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .chip{
      border:1px solid var(--muted);
      background:var(--panel);
      color:var(--text);
      padding:.35rem .6rem;
      border-radius:.5rem;
      font-size:.92rem;
      box-shadow: var(--shadow);
    }
    .state{ display:inline-flex; align-items:center; gap:.4rem; }
    .dot{ width:.55rem; height:.55rem; border-radius:999px; display:inline-block; background: var(--primary); }
    .dot.ok{ background: var(--good); }

    /* 차트(라인/축/격자) */
    .axis path, .axis line{ stroke: var(--muted); shape-rendering: crispEdges; }
    .gridline line{ stroke: var(--grid); }
    .gridline .domain{ display:none; }

    .series-birth{ stroke: var(--accent); fill: none; stroke-width: 2.5; }
    .series-death{ stroke: var(--accent2); fill: none; stroke-width: 2.5; }
    .series-income{ stroke: var(--good);   fill: none; stroke-width: 2.5; }

    .prev-birth, .prev-death, .prev-income{
      fill:none; stroke-width:2.5; stroke-dasharray:6 6; opacity:.65;
    }
    .prev-birth{ stroke: var(--accent); }
    .prev-death{ stroke: var(--accent2); }
    .prev-income{ stroke: var(--good); }

    .current-line{ stroke: var(--text); stroke-width:2; stroke-dasharray:3 6; opacity:.95; }
    .eq0-line{ stroke: var(--muted); stroke-width:1.5; stroke-dasharray:2 4; opacity:.6; }
    .h-guide{ stroke: var(--text); stroke-width:1.6; stroke-dasharray:4 6; opacity:.9; }
    .equilibrium{ fill: #fff; stroke: #000; stroke-width: .6; }
    .eq1-dot{ fill: var(--warning, #ffb85c); stroke:#000; stroke-width:.6; }

    /* 수동 범례 (다른 페이지와 톤 맞춤) */
    .legend{ position:absolute; right: .75rem; top: .5rem; background: color-mix(in oklab, var(--panel) 70%, black 30%); border:1px solid var(--line); border-radius:.6rem; padding:.35rem .5rem; display:flex; gap:.6rem; align-items:center; }
    .legend span{ display:inline-flex; gap:.35rem; align-items:center; font-size:.8rem; color:var(--muted); }
    .legend i{ width:16px; height:3px; display:inline-block; border-radius: 999px; }
  </style>
</head>

<body>
  <header class="site-header">
    <h1>맬서스 트랩 – 두 가지 핵심 그림</h1>
    <p class="subtitle">각 시나리오에서 <em>곡선이 먼저 천천히 이동</em>하고, 이후 <kbd>N(t)</kbd>가 새 목표로 수렴합니다. 시나리오 3(기술 진보)에서는 수평 점선으로 <kbd>y*</kbd>가 같음을 표시합니다.</p>
  </header>

  <main class="grid">
    <!-- (A) 시나리오 & 실시간 측정기 -->
    <section class="card controls" aria-label="시나리오 · 실시간 측정기">
      <h2 style="margin:0;">시나리오</h2>
      <div class="row" role="group" aria-label="시나리오 버튼">
        <button id="scenario1" class="primary">시나리오 1: 출생률 외생 증가</button>
        <button id="scenario2" class="primary">시나리오 2: 사망률 외생 증가</button>
        <button id="scenario3" class="primary">시나리오 3: 기술 진보</button>
        <button id="reset" title="초기 상태로 되돌리기">초기화</button>
      </div>
      <div class="meter" aria-live="polite">
        <span class="chip">N(t): <b id="mN">–</b></span>
        <span class="chip">y(t): <b id="mY">–</b></span>
        <span class="chip">b(y): <b id="mB">–</b>% · d(y): <b id="mD">–</b>%</span>
        <span class="chip state"><i class="dot" id="mDot" aria-hidden="true"></i><span id="mState">대기</span></span>
        <span class="chip">y* (고정): <b id="mYStar0">–</b></span>
      </div>
    </section>

    <!-- (B) 차트 1 -->
    <section class="card" aria-label="소득에 따른 출생·사망률">
      <h2>출생률·사망률 vs 1인당 소득</h2>
      <p class="muted" style="margin:.1rem 0 .5rem;">가로축: 1인당 소득(0–100), 세로축: 연간 비율(%) — 흰 점선은 현재 <em>y(t)</em>. 초기 교차점 표시는 숨김, <span style="color:var(--warning, #ffb85c)">노란 점</span>은 시나리오 1·2에서 새 교차점 도달 시에만 표시. <strong>점선=변경 전 곡선</strong></p>
      <div class="chart-wrap">
        <div id="chart1" class="chart" role="img" aria-label="소득에 따른 출생률과 사망률 곡선"></div>
        <div class="legend" aria-hidden="true">
          <span><i style="background: var(--accent)"></i> 출생률</span>
          <span><i style="background: var(--accent2)"></i> 사망률</span>
        </div>
      </div>
    </section>

    <!-- (C) 차트 2 -->
    <section class="card" aria-label="인구에 따른 1인당 소득">
      <h2>1인당 소득 vs 인구 (선형 우하향)</h2>
      <p class="muted" style="margin:.1rem 0 .5rem;">가로축: 인구 N(50–150), 세로축: 1인당 소득(0–100) — <span style="color:#cfd8ea">회색 점</span>은 초기 균형, <span style="color:var(--primary)">파란 점</span>은 현재 상태. 시나리오 3에서 곡선 전체가 상방 이동. <strong>점선=변경 전 곡선</strong></p>
      <div class="chart-wrap">
        <div id="chart2" class="chart" role="img" aria-label="인구와 1인당 소득의 선형 우하향 관계"></div>
        <div class="legend" aria-hidden="true">
          <span><i style="background: var(--good)"></i> y(N)=a−s·N</span>
          <span><i style="background: var(--text)"></i> y(t) (현재)</span>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
    <small>© <span id="year"></span> aries0401-svc</small>
  </footer>

  <!-- 공통 스크립트 -->
  <script src="../../assets/site.js"></script>

  <!-- 페이지 전용 스크립트 -->
  <script>
  (function(){
    'use strict';

    // ──────────────────────────────────────────────────────────────────────
    // 0) 공통 유틸
    // ──────────────────────────────────────────────────────────────────────
    const clamp = (x,min,max)=> Math.max(min, Math.min(max, x));
    const fmt = (v, p=2)=> (Math.round(v * 10**p) / 10**p).toFixed(p);

    // ──────────────────────────────────────────────────────────────────────
    // 1) 모형 파라미터 (그래프 1: b(y), d(y))
    // ──────────────────────────────────────────────────────────────────────
    const birthBase = { b0: 1.5, b1: 2.5, k: 0.03 };     // [%/년]
    const deathBase = { dmin: 1.5, drop: 4.0, m: 0.04 }; // [%/년]

    let birthParams = {...birthBase};
    let deathParams = {...deathBase};

    const b = (y)=> birthParams.b0 + birthParams.b1 * (1 - Math.exp(-birthParams.k*y));
    const d = (y)=> deathParams.dmin + deathParams.drop * Math.exp(-deathParams.m*y);

    function findIncomeSteadyState(yMin=0, yMax=100, step=0.02){
      let bestY=yMin, bestGap=Infinity;
      for(let y=yMin; y<=yMax; y+=step){
        const gap = Math.abs(b(y) - d(y));
        if(gap < bestGap){ bestGap = gap; bestY = y; }
      }
      return bestY;
    }

    // ──────────────────────────────────────────────────────────────────────
    // 2) 선형 소득-인구 y(N) = a − s·N
    // ──────────────────────────────────────────────────────────────────────
    const lin = { slope: 0.25, Nmin: 50, Nmax: 150, N0: 100 };
    let yStar0 = findIncomeSteadyState();
    let aIntercept = yStar0 + lin.slope * lin.N0; // y(N0) = y*0 (초기)

    const yOfN      = (N)=> aIntercept - lin.slope * N;
    const yOfNWith  = (a,N)=> a - lin.slope * N;
    const findNstarWithA = (a,y)=> (a - y) / lin.slope;
    const findNstar = (y)=> (aIntercept - y) / lin.slope;

    // ──────────────────────────────────────────────────────────────────────
    // 3) 상태
    // ──────────────────────────────────────────────────────────────────────
    let currentN = lin.N0;
    let targetN = lin.N0;
    let yStarNew = yStar0;           // 시나리오1·2에서만 변경
    let timer = null;
    let scenarioActive = false;

    // ──────────────────────────────────────────────────────────────────────
    // 4) SVG 구성 (차트 1)
    // ──────────────────────────────────────────────────────────────────────
    const svg1 = d3.select('#chart1').append('svg')
      .attr('viewBox', '0 0 640 360')
      .attr('preserveAspectRatio','xMidYMid meet')
      .style('width','100%').style('height','100%');

    const m1 = {t:18, r:14, b:36, l:48};
    const W1 = 640 - m1.l - m1.r, H1 = 360 - m1.t - m1.b;
    const g1 = svg1.append('g').attr('transform', `translate(${m1.l},${m1.t})`);
    const x1 = d3.scaleLinear().domain([0,100]).range([0,W1]);
    const y1 = d3.scaleLinear().domain([0,6.2]).range([H1,0]);

    g1.append('g').attr('class','gridline').attr('transform',`translate(0,${H1})`).call(d3.axisBottom(x1).tickSize(-H1).tickFormat(''));
    g1.append('g').attr('class','gridline').call(d3.axisLeft(y1).tickSize(-W1).tickFormat(''));
    g1.append('g').attr('class','axis').attr('transform',`translate(0,${H1})`).call(d3.axisBottom(x1));
    g1.append('g').attr('class','axis').call(d3.axisLeft(y1).ticks(6));

    const line1 = d3.line().x(d=>x1(d.x)).y(d=>y1(d.y)).curve(d3.curveMonotoneX);
    const xs = d3.range(0, 100.001, 0.5);

    // 변경 전(점선) 경로
    const prevBirthPath = g1.append('path').attr('class','prev-birth').style('opacity',0);
    const prevDeathPath = g1.append('path').attr('class','prev-death').style('opacity',0);

    // 현재 경로
    const birthPath = g1.append('path').attr('class','series-birth');
    const deathPath = g1.append('path').attr('class','series-death');
    const currentYLine = g1.append('line').attr('class','current-line');
    const eq0Line = g1.append('line').attr('class','eq0-line');
    const eq1Dot = g1.append('circle').attr('class','eq1-dot').attr('r', 5).style('opacity',0); // 새 교차점(시나리오1·2)

    g1.append('text').attr('x', W1/2).attr('y', H1+28).attr('text-anchor','middle').attr('fill','var(--muted)').text('1인당 소득');
    g1.append('text').attr('x', -H1/2).attr('y', -36).attr('transform','rotate(-90)').attr('text-anchor','middle').attr('fill','var(--muted)').text('연간 비율(%)');

    function drawChart1(){
      const birthData = xs.map(x=>({x, y: b(x)}));
      const deathData = xs.map(x=>({x, y: d(x)}));
      birthPath.datum(birthData).attr('d', line1);
      deathPath.datum(deathData).attr('d', line1);

      // 초기 균형: 세로 점선만 유지
      eq0Line.attr('x1', x1(yStar0)).attr('x2', x1(yStar0)).attr('y1', 0).attr('y2', H1);

      // 현재 y(t) 세로선
      const yNow = yOfN(currentN);
      currentYLine.attr('x1', x1(yNow)).attr('x2', x1(yNow)).attr('y1', 0).attr('y2', H1);

      // 새 교차점(노란 점) 위치 갱신(표시는 시나리오1·2 완료 시)
      eq1Dot.attr('cx', x1(yStarNew)).attr('cy', y1(b(yStarNew)));
    }

    // ──────────────────────────────────────────────────────────────────────
    // 5) SVG 구성 (차트 2)
    // ──────────────────────────────────────────────────────────────────────
    const svg2 = d3.select('#chart2').append('svg')
      .attr('viewBox', '0 0 640 360')
      .attr('preserveAspectRatio','xMidYMid meet')
      .style('width','100%').style('height','100%');

    const m2 = {t:18, r:14, b:36, l:48};
    const W2 = 640 - m2.l - m2.r, H2 = 360 - m2.t - m2.b;
    const g2 = svg2.append('g').attr('transform', `translate(${m2.l},${m2.t})`);
    const x2 = d3.scaleLinear().domain([lin.Nmin, lin.Nmax]).range([0,W2]);
    const y2 = d3.scaleLinear().domain([0,100]).range([H2,0]);

    g2.append('g').attr('class','gridline').attr('transform',`translate(0,${H2})`).call(d3.axisBottom(x2).tickSize(-H2).tickFormat(''));
    g2.append('g').attr('class','gridline').call(d3.axisLeft(y2).tickSize(-W2).tickFormat(''));
    g2.append('g').attr('class','axis').attr('transform',`translate(0,${H2})`).call(d3.axisBottom(x2));
    g2.append('g').attr('class','axis').call(d3.axisLeft(y2));

    const line2 = d3.line().x(d=>x2(d.N)).y(d=>y2(d.y)).curve(d3.curveLinear);
    // 변경 전(점선) 경로
    const prevIncomePath = g2.append('path').attr('class','prev-income').style('opacity',0);
    // 현재 경로
    const curve2Path = g2.append('path').attr('class','series-income');
    const eq0DotR = g2.append('circle').attr('class','equilibrium').attr('r',4.5).style('fill','#cfd8ea'); // 오른쪽 초기 균형(회색)
    const statePt = g2.append('circle').attr('class','equilibrium').attr('r',5).style('fill','var(--primary)');
    const yStarGuide = g2.append('line').attr('class','h-guide').style('opacity',0); // 시나리오3용 수평 보조선

    g2.append('text').attr('x', W2/2).attr('y', H2+28).attr('text-anchor','middle').attr('fill','var(--muted)').text('인구 N');
    g2.append('text').attr('x', -H2/2).attr('y', -36).attr('transform','rotate(-90)').attr('text-anchor','middle').attr('fill','var(--muted)').text('1인당 소득');

    function drawChart2(){
      const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
      const data = Ns.map(N=> ({N, y: yOfN(N)}));
      curve2Path.datum(data).attr('d', line2);

      const yNow = yOfN(currentN);
      statePt.attr('cx', x2(currentN)).attr('cy', y2(yNow));

      // 초기 균형점(오른쪽) – 고정
      eq0DotR.attr('cx', x2(lin.N0)).attr('cy', y2(yStar0));

      // 시나리오3 보조선 (y = y*0)
      yStarGuide.attr('x1', 0).attr('x2', W2).attr('y1', y2(yStar0)).attr('y2', y2(yStar0));

      g2.selectAll('.n-label').data([currentN]).join('text')
        .attr('class','n-label')
        .attr('x', d => x2(d)+6)
        .attr('y', d => y2(yOfN(d)) - 8)
        .attr('fill', 'var(--muted)')
        .attr('font-size', 11)
        .text(d => `N(t) ≈ ${fmt(d,1)}, y(t) ≈ ${fmt(yOfN(d),1)}`);
    }

    // ──────────────────────────────────────────────────────────────────────
    // 6) 측정기
    // ──────────────────────────────────────────────────────────────────────
    const mN = document.getElementById('mN');
    const mY = document.getElementById('mY');
    const mB = document.getElementById('mB');
    const mD = document.getElementById('mD');
    const mState = document.getElementById('mState');
    const mDot = document.getElementById('mDot');
    const mYStar0 = document.getElementById('mYStar0');

    function updateMeter(){
      const yNow = yOfN(currentN);
      const by = b(yNow), dy = d(yNow), g = by - dy;
      mN.textContent = fmt(currentN,1);
      mY.textContent = fmt(yNow,1);
      mB.textContent = fmt(by,2);
      mD.textContent = fmt(dy,2);
      mYStar0.textContent = fmt(yStar0,1);

      const delta = Math.abs(targetN - currentN);
      if(delta < 0.02){
        mState.textContent = '균형 도달';
        mDot.classList.add('ok');
      } else {
        mState.textContent = (g >= 0 ? '진행 중: 인구 ↑' : '진행 중: 인구 ↓');
        mDot.classList.remove('ok');
      }
    }

    // ──────────────────────────────────────────────────────────────────────
    // 7) 초기 렌더
    // ──────────────────────────────────────────────────────────────────────
    function renderAll(){ drawChart1(); drawChart2(); updateMeter(); }
    renderAll();

    // ──────────────────────────────────────────────────────────────────────
    // 8) 시나리오 실행/초기화
    // ──────────────────────────────────────────────────────────────────────
    const scenario1Btn = document.getElementById('scenario1');
    const scenario2Btn = document.getElementById('scenario2');
    const scenario3Btn = document.getElementById('scenario3');
    const resetBtn     = document.getElementById('reset');

    function runToTarget({showEqDot=true}={}){
      if(timer) timer.stop();
      let last = performance.now();
      const speed = 0.35; // 완만하지만 끝이 보이게
      const eps = 0.05;   // 스냅 임계값
      timer = d3.timer(()=>{
        const now = performance.now();
        const dt = Math.min(0.05, (now - last)/1000);
        last = now;
        currentN += speed * dt * (targetN - currentN);
        if(Math.abs(targetN - currentN) < eps){
          currentN = targetN;
          timer.stop();
          if(showEqDot){ d3.select(eq1Dot.node()).transition().duration(250).style('opacity',1); }
        }
        renderAll();
      });
    }

    function lockScenarios(){
      scenarioActive = true;
      scenario1Btn.disabled = true;
      scenario2Btn.disabled = true;
      scenario3Btn.disabled = true;
    }

    // 시나리오 1: 출생률 외생 증가 (출생률 곡선 상방 이동 → y*↓, N*↑)
    function startScenario1(){
      if(scenarioActive) return; lockScenarios();

      // 변경 전 곡선(점선) 저장
      const birthDataOld = xs.map(x=>({x, y: b(x)}));
      prevBirthPath.datum(birthDataOld).attr('d', line1).style('opacity',.65);

      // 새 파라미터 적용
      birthParams = {...birthParams, b0: birthParams.b0 + 0.6};
      yStarNew = findIncomeSteadyState();
      targetN = clamp(findNstar(yStarNew), lin.Nmin, lin.Nmax);

      const birthDataNew = xs.map(x=>({x, y: b(x)}));
      birthPath
        .datum(birthDataNew)
        .transition().duration(1200).ease(d3.easeCubicInOut)
        .attr('d', line1)
        .on('end', ()=> runToTarget({showEqDot:true})); // 곡선 이동 후 N 수렴 시작
    }

    // 시나리오 2: 사망률 외생 증가 (사망률 곡선 상방 이동 → y*↑, N*↓)
    function startScenario2(){
      if(scenarioActive) return; lockScenarios();

      // 변경 전 곡선(점선) 저장
      const deathDataOld = xs.map(x=>({x, y: d(x)}));
      prevDeathPath.datum(deathDataOld).attr('d', line1).style('opacity',.65);

      // 새 파라미터 적용
      deathParams = {...deathParams, dmin: deathParams.dmin + 0.6};
      yStarNew = findIncomeSteadyState();
      targetN = clamp(findNstar(yStarNew), lin.Nmin, lin.Nmax);

      const deathDataNew = xs.map(x=>({x, y: d(x)}));
      deathPath
        .datum(deathDataNew)
        .transition().duration(1200).ease(d3.easeCubicInOut)
        .attr('d', line1)
        .on('end', ()=> runToTarget({showEqDot:true}));
    }

    // 시나리오 3: 기술 진보 (y(N) 상방 이동 → 초기엔 y↑, b>d → N↑ → y가 y*로 회귀)
    function startScenario3(){
      if(scenarioActive) return; lockScenarios();

      // 변경 전 곡선(점선) 저장
      const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
      const dataOld = Ns.map(N=> ({N, y: yOfN(N)}));
      prevIncomePath.datum(dataOld).attr('d', line2).style('opacity',.65);

      // 기술 충격: 절편 a 상향 (단, 곡선 애니메이션이 끝날 때까지 전역 aIntercept는 보류)
      const techBoost = 8;
      const aNew = aIntercept + techBoost;

      // 새 곡선 데이터(전역 반영 전)
      const dataNew = Ns.map(N=> ({N, y: yOfNWith(aNew,N)}));

      // 수평 보조선 표시
      d3.select(yStarGuide.node()).transition().duration(400).style('opacity',1);

      // 곡선 먼저 천천히 이동
      d3.select(curve2Path.node())
        .datum(dataNew)
        .transition().duration(1200).ease(d3.easeCubicInOut)
        .attr('d', line2)
        .on('end', ()=>{
          // 이제 전역 aIntercept를 갱신하고, N을 y*로 돌려보냄
          aIntercept = aNew;
          targetN = clamp(findNstarWithA(aIntercept, yStar0), lin.Nmin, lin.Nmax);
          // 노란 점 비활성(이 케이스는 y* 고정 회귀)
          d3.select(eq1Dot.node()).style('opacity',0);
          runToTarget({showEqDot:false});
        });
    }

    function resetAll(){
      if(timer) timer.stop();
      birthParams = {...birthBase};
      deathParams = {...deathBase};
      yStar0 = findIncomeSteadyState();
      yStarNew = yStar0;
      aIntercept = yStar0 + lin.slope * lin.N0; // 기술 이전 상태로 복원
      currentN = lin.N0;
      targetN = currentN;

      d3.select(eq1Dot.node()).style('opacity',0);
      scenarioActive = false;
      scenario1Btn.disabled = false;
      scenario2Btn.disabled = false;
      scenario3Btn.disabled = false;

      // 곡선 원복
      const birthDataBase = xs.map(x=>({x, y: b(x)}));
      const deathDataBase = xs.map(x=>({x, y: d(x)}));
      birthPath.datum(birthDataBase).attr('d', line1);
      deathPath.datum(deathDataBase).attr('d', line1);

      const Ns = d3.range(lin.Nmin, lin.Nmax+0.001, 1);
      const dataBase = Ns.map(N=> ({N, y: yOfN(N)}));
      d3.select(curve2Path.node()).datum(dataBase).attr('d', line2);

      // 점선/보조선 숨김
      prevBirthPath.style('opacity',0);
      prevDeathPath.style('opacity',0);
      prevIncomePath.style('opacity',0);
      d3.select(yStarGuide.node()).style('opacity',0);

      renderAll();
    }

    // 이벤트
    scenario1Btn.addEventListener('click', startScenario1);
    scenario2Btn.addEventListener('click', startScenario2);
    scenario3Btn.addEventListener('click', startScenario3);
    resetBtn.addEventListener('click', resetAll);

    // 연도 표기 (프로젝트 공통 패턴 유지)
    document.addEventListener('DOMContentLoaded', ()=>{
      const y=document.querySelector('#year'); if(y) y.textContent=new Date().getFullYear();
    });
  })();
  </script>
</body>
</html>

