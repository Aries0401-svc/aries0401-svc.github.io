<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>계량경제학 · 표준정규분포(표식 & p-value)</title>

  <!-- 공통 스타일 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    /* 컨트롤 영역 */
    .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end;margin-bottom:16px}
    .ctrl{background:var(--panel);border:1px solid rgba(255,255,255,.08);padding:12px 14px;border-radius:12px;box-shadow: var(--shadow)}
    .ctrl label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}

    /* 드롭다운/인풋 가시성 개선 */
    .ctrl select,.ctrl input{
      width:180px;background:var(--panel);color:var(--text);
      border:1px solid rgba(255,255,255,.15);border-radius:8px;padding:8px 10px;
    }
    .ctrl select:focus,.ctrl input:focus{outline:none;box-shadow:0 0 0 4px var(--ring)}
    select option{background:var(--panel);color:var(--text);}
    @media (prefers-color-scheme: light){
      select option{background:#ffffff;color:#0f172a;}
    }

    /* p-value 박스(컨트롤 오른쪽) */
    .stat{
      min-width:240px; display:flex; flex-direction:column; gap:4px;
      background:linear-gradient(180deg, rgba(106,169,255,.12), rgba(106,169,255,.06)) , var(--panel);
      border:1px solid rgba(106,169,255,.35);
    }
    .stat .label{font-size:12px;color:var(--muted)}
    .stat .value{
      font-variant-numeric: tabular-nums;
      font-weight:700; font-size:26px; line-height:1.1;
    }
    .stat .meta{font-size:12px;color:var(--muted)}

    canvas{background:var(--panel);border-radius:18px;box-shadow: var(--shadow);padding:10px}
    .hint{color:var(--muted);font-size:14px;margin-top:8px}
  </style>
</head>
<body>
  <header class="site-header">
    <h1>표준정규분포 시각화</h1>
    <p class="subtitle">μ=0, σ=1 고정 · 신뢰구간 표식(선/화살표) · p-value 계산</p>
  </header>

  <main class="grid" style="grid-template-columns:1fr;">
    <section class="card">
      <!-- 컨트롤 -->
      <div class="controls">
        <div class="ctrl">
          <label for="zValue">z-통계량 (p-value 계산)</label>
          <input id="zValue" type="number" step="0.01" value="1.96" />
        </div>

        <div class="ctrl">
          <label for="tailType">검정 방향</label>
          <select id="tailType">
            <option value="two" selected>양측검정 (two-tailed)</option>
            <option value="right">우측검정 (right-tailed)</option>
            <option value="left">좌측검정 (left-tailed)</option>
          </select>
        </div>

        <!-- p-value 박스(오른쪽) -->
        <div class="ctrl stat" id="pBox">
          <div class="label">p-value</div>
          <div class="value" id="pBoxValue">—</div>
          <div class="meta" id="pBoxMeta">—</div>
        </div>
      </div>

      <!-- 그래프 -->
      <canvas id="chart" height="120"></canvas>

      <div class="hint">
        ※ p-value는 표준정규 CDF 공식으로 계산합니다.
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 계량경제학 홈</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
  </footer>

  <script src="../../assets/site.js"></script>
  <script>
    // ====== 표준정규 함수 (μ=0, σ=1) ======
    const pdf = (x) => Math.exp(-0.5 * x*x) / Math.sqrt(2*Math.PI);

    // 표준정규 CDF 근사
    function stdNormCdf(z){
      const t = 1/(1+0.2316419*Math.abs(z));
      const d = Math.exp(-z*z/2)/Math.sqrt(2*Math.PI);
      let p = d*(0.319381530*t - 0.356563782*t**2 + 1.781477937*t**3 - 1.821255978*t**4 + 1.330274429*t**5);
      if(z>0) p = 1-p;
      return p;
    }

    // ====== 신뢰구간 표식(수직선 + 화살표 + 라벨) ======
    // 라벨에 ±z 값을 포함 (숫자 위쪽 표기는 제거)
    const CI_MARKS = [
      {z:1.645, label:"90% 신뢰구간 (±1.645)"},
      {z:1.96,  label:"95% 신뢰구간 (±1.96)"},
      {z:2.576, label:"99% 신뢰구간 (±2.576)"},
    ];

    const ciMarkersPlugin = {
      id: 'ciMarkers',
      afterDatasetsDraw(chart){
        const {ctx, chartArea:{top, bottom}, scales:{x, y}} = chart;

        const css = getComputedStyle(document.documentElement);
        const color = (css.getPropertyValue('--primary') || '#6aa9ff').trim();

        ctx.save();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 2;

        const bottomPix = y.getPixelForValue(0);
        const topPix = top + (bottom - top) * 0.14;   // 수직선 상단

        // 화살표가 겹치지 않도록 Y 좌표 분리
        const arrowYs = [
          top + (bottom - top) * 0.24, // 90%
          top + (bottom - top) * 0.32, // 95%
          top + (bottom - top) * 0.40, // 99%
        ];

        // 화살표 그리기
        function drawArrow(x1, y0, x2){
          ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x2,y0); ctx.stroke();
          const head=6;
          // 왼쪽 화살촉
          ctx.beginPath();
          ctx.moveTo(x1,y0);
          ctx.lineTo(x1+head,y0-head);
          ctx.lineTo(x1+head,y0+head);
          ctx.closePath(); ctx.fill();
          // 오른쪽 화살촉
          ctx.beginPath();
          ctx.moveTo(x2,y0);
          ctx.lineTo(x2-head,y0-head);
          ctx.lineTo(x2-head,y0+head);
          ctx.closePath(); ctx.fill();
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.font = '12px "Noto Sans KR", system-ui, -apple-system, Segoe UI, Roboto, sans-serif';

        CI_MARKS.forEach((m, i)=>{
          const xl = x.getPixelForValue(-m.z);
          const xr = x.getPixelForValue(+m.z);

          // 1) 수직선 두 개(숫자 표기는 더 이상 그리지 않음)
          ctx.beginPath(); ctx.moveTo(xl, bottomPix); ctx.lineTo(xl, topPix); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(xr, bottomPix); ctx.lineTo(xr, topPix); ctx.stroke();

          // 2) 양끝 화살표 + 라벨(라벨에 ±z 포함)
          const yArrow = arrowYs[i];
          drawArrow(xl+2, yArrow, xr-2);
          ctx.fillText(m.label, (xl+xr)/2, yArrow-4);
        });

        ctx.restore();
      }
    };

    // ====== 차트 세팅 ======
    function buildCurve(){
      const n = 801, xmin = -4.5, xmax = 4.5;
      const step = (xmax - xmin) / (n-1);
      const curve = [];
      for(let i=0;i<n;i++){
        const x = xmin + i*step;
        curve.push({x, y: pdf(x)});
      }
      return curve;
    }

    function makeShade(predicate){
      const base = chart.data.datasets[0].data;
      return base.map(p => ({x: p.x, y: predicate(p.x) ? p.y : null}));
    }

    const ctx = document.getElementById('chart');
    Chart.register(ciMarkersPlugin);

    const chart = new Chart(ctx, {
      type: 'line',
      data: { datasets: [
        {label: '표준정규 f(z)', data: [], parsing:false, borderWidth:2, pointRadius:0, tension:0.15},
        {label: 'p-value 영역', data: [], parsing:false, borderWidth:0, pointRadius:0, fill:'origin', hidden:false}
      ]},
      options: {
        responsive: true,
        animation: {duration: 200},
        plugins: {
          legend: {display:true},
          tooltip: {mode:'index', intersect:false, callbacks:{
            label: (ctx) => ctx.datasetIndex===0 ? ` f(z) ≈ ${ctx.parsed.y.toFixed(5)}` : null
          }}
        },
        scales: {
          x: {type:'linear', title:{display:true, text:'z'}, suggestedMin:-4.5, suggestedMax:4.5},
          y: {title:{display:true, text:'밀도 f(z)'}}
        }
      }
    });

    // ====== p-value 계산/표시 ======
    const zInput = document.getElementById('zValue');
    const tailSel = document.getElementById('tailType');
    const pBoxValue = document.getElementById('pBoxValue');
    const pBoxMeta  = document.getElementById('pBoxMeta');

    function formatProb(p){
      if (p < 1e-4) return p.toExponential(2);
      return p.toFixed(4);
    }

    function update(){
      // 곡선(한 번만 구성)
      if(chart.data.datasets[0].data.length === 0){
        chart.data.datasets[0].data = buildCurve();
      }

      // p-value 계산 + 음영 표시
      const z = parseFloat(zInput.value);
      const tail = tailSel.value;
      let p, meta;

      if(tail === 'two'){
        const zabs = Math.abs(z);
        p = 2 * (1 - stdNormCdf(zabs));
        chart.data.datasets[1].data = makeShade(x => Math.abs(x) >= zabs);
        meta = `양측, |z|=${zabs.toFixed(2)} → P(|Z| ≥ ${zabs.toFixed(2)})`;
      }else if(tail === 'right'){
        p = 1 - stdNormCdf(z);
        chart.data.datasets[1].data = makeShade(x => x >= z);
        meta = `우측, z=${z.toFixed(2)} → P(Z ≥ ${z.toFixed(2)})`;
      }else{ // left
        p = stdNormCdf(z);
        chart.data.datasets[1].data = makeShade(x => x <= z);
        meta = `좌측, z=${z.toFixed(2)} → P(Z ≤ ${z.toFixed(2)})`;
      }

      pBoxValue.textContent = formatProb(p);
      pBoxMeta.textContent  = meta;

      chart.update();
    }

    [zInput, tailSel].forEach(el => el.addEventListener('input', update));
    update();
  </script>
</body>
</html>
