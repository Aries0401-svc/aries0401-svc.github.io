<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>계량경제학 · t-분포(표식 & p-value)</title>

  <!-- 공통 스타일 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-start;margin-bottom:16px}
    .ctrl{background:var(--panel);border:1px solid rgba(255,255,255,.08);padding:12px 14px;border-radius:12px;box-shadow: var(--shadow)}
    .ctrl label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    .ctrl select,.ctrl input{width:180px;background:var(--panel);color:var(--text);border:1px solid rgba(255,255,255,.15);border-radius:8px;padding:8px 10px}
    .ctrl select:focus,.ctrl input:focus{outline:none;box-shadow:0 0 0 4px var(--ring)}
    select option{background:var(--panel);color:var(--text)}
    @media (prefers-color-scheme: light){ select option{background:#fff;color:#0f172a} }

    /* p-value 박스를 항상 오른쪽 첫 줄에 고정 */
    .stat{
      min-width:240px; width:280px; flex:0 0 280px;
      order:99; margin-left:auto;
      display:flex; flex-direction:column; gap:4px;
      background:linear-gradient(180deg, rgba(106,169,255,.12), rgba(106,169,255,.06)), var(--panel);
      border:1px solid rgba(106,169,255,.35);
    }
    .stat .label{font-size:12px;color:var(--muted)}
    .stat .value{font-variant-numeric:tabular-nums;font-weight:700;font-size:26px;line-height:1.1}
    .stat .meta{font-size:12px;color:var(--muted)}

    canvas{background:var(--panel);border-radius:18px;box-shadow:var(--shadow);padding:10px}
    .hint{color:var(--muted);font-size:14px;margin-top:8px}
  </style>
</head>
<body>
  <header class="site-header">
    <h1>t-분포 시각화</h1>
    <p class="subtitle">스튜던트 t (자유도 ν) · 신뢰구간 표식(선/화살표) · p-value 계산</p>
  </header>

  <main class="grid" style="grid-template-columns:1fr;">
    <section class="card">
      <!-- 컨트롤 -->
      <div class="controls">
        <div class="ctrl">
          <label for="dfValue">자유도 ν</label>
          <input id="dfValue" type="number" step="1" min="1" value="10" />
        </div>

        <div class="ctrl">
          <label for="tValue">t-통계량 (p-value 계산)</label>
          <input id="tValue" type="number" step="0.01" value="2.228" inputmode="decimal" />
        </div>

        <div class="ctrl">
          <label for="tailType">검정 방향</label>
          <select id="tailType">
            <option value="two" selected>양측검정 (two-tailed)</option>
            <option value="right">우측검정 (right-tailed)</option>
            <option value="left">좌측검정 (left-tailed)</option>
          </select>
        </div>

        <!-- p-value 박스 (오른쪽 고정) -->
        <div class="ctrl stat" id="pBox" aria-live="polite">
          <div class="label">p-value</div>
          <div class="value" id="pBoxValue">—</div>
          <div class="meta" id="pBoxMeta">—</div>
        </div>
      </div>

      <!-- 그래프 -->
      <canvas id="chart" height="120"></canvas>

      <div class="hint">
        ※ CDF는 정규화 불완전 베타함수(연분수; Lentz) 기반, PDF는 Γ함수(Lanczos) 기반으로 계산합니다.
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
  </footer>

  <script src="../../assets/site.js"></script>
  <script>
    /* ===== 색상 (정규 페이지와 동일 규칙) ===== */
    function cssVar(name){ const v=getComputedStyle(document.documentElement).getPropertyValue(name); return (v&&v.trim())||null; }
    function withAlpha(color, a){
      if(!color) return `rgba(239,68,68,${a})`;
      if(color.startsWith('#')){
        const hex=color.length===4?('#'+color[1]+color[1]+color[2]+color[2]+color[3]+color[3]):color;
        const aa=Math.round(a*255).toString(16).padStart(2,'0');
        return hex+aa;
      }
      if(color.startsWith('rgb(')) return color.replace('rgb(','rgba(').replace(')',`, ${a})`);
      if(color.startsWith('hsl(')) return color.replace('hsl(','hsla(').replace(')',`, ${a})`);
      return color;
    }
    const BLUE = cssVar('--primary') || '#60A5FA';        // 곡선
    const RED  = cssVar('--danger')  || '#EF4444';        // 음영
    const SHADE = withAlpha(RED, 0.55);

    /* ===== 수학 ===== */
    const clamp=(v,lo,hi)=>Math.min(hi,Math.max(lo,v));
    function formatProb(p){ if(!Number.isFinite(p)) return '—'; p=clamp(p,0,1); return p<1e-6? p.toExponential(2):p.toFixed(6); }

    function logGamma(z){
      const p=[0.99999999999980993,676.5203681218851,-1259.1392167224028,771.32342877765313,-176.61502916214059,12.507343278686905,-0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
      const g=7;
      if(z<0.5){ return Math.log(Math.PI)-Math.log(Math.sin(Math.PI*z))-logGamma(1-z); }
      z-=1; let x=p[0]; for(let i=1;i<p.length;i++) x+=p[i]/(z+i);
      const t=z+g+0.5; return 0.5*Math.log(2*Math.PI)+(z+0.5)*Math.log(t)-t+Math.log(x);
    }
    function betacf(a,b,x){
      const MAXIT=200,EPS=3e-7,FPMIN=1e-300; let qab=a+b,qap=a+1,qam=a-1; let c=1,d=1-qab*x/qap; if(Math.abs(d)<FPMIN)d=FPMIN; d=1/d; let h=d;
      for(let m=1;m<=MAXIT;m++){ const m2=2*m;
        let aa=m*(b-m)*x/((qam+m2)*(a+m2)); d=1+aa*d; if(Math.abs(d)<FPMIN)d=FPMIN; d=1/d; c=1+aa/c; if(Math.abs(c)<FPMIN)c=FPMIN; h*=d*c;
        aa=-(a+m)*(qab+m)*x/((a+m2)*(qap+m2)); d=1+aa*d; if(Math.abs(d)<FPMIN)d=FPMIN; d=1/d; c=1+aa/c; if(Math.abs(c)<FPMIN)c=FPMIN; const del=d*c; h*=del;
        if(Math.abs(del-1)<EPS) break;
      } return h;
    }
    function incbetaReg(x,a,b){
      if(x<=0) return 0; if(x>=1) return 1;
      const lnBt=logGamma(a+b)-logGamma(a)-logGamma(b)+a*Math.log(x)+b*Math.log(1-x);
      const bt=Math.exp(lnBt);
      if(x<(a+1)/(a+b+2)) return bt*betacf(a,b,x)/a;
      return 1-(bt*betacf(b,a,1-x)/b);
    }
    function pdfT(x,v){
      const lnC=logGamma((v+1)/2)-logGamma(v/2)-0.5*(Math.log(v)+Math.log(Math.PI));
      const lnK=-((v+1)/2)*Math.log(1+(x*x)/v);
      return Math.exp(lnC+lnK);
    }
    function cdfT(x,v){
      const a=v/2,b=0.5,t=v/(v+x*x),I=incbetaReg(t,a,b);
      return (x>=0)?1-0.5*I:0.5*I;
    }
    function invCdfT(p,v){
      if(p<=0) return -Infinity; if(p>=1) return Infinity; if(p===0.5) return 0;
      const sign=p<0.5?-1:1, target=p<0.5?1-p:p;
      let lo=0,hi=1; while(cdfT(hi,v)<target){hi*=2;if(hi>1e6)break;}
      for(let i=0;i<80;i++){ const mid=(lo+hi)/2, F=cdfT(mid,v); if(F<target) lo=mid; else hi=mid; }
      return sign*(lo+hi)/2;
    }

    /* ===== 신뢰구간 플러그인 ===== */
    const CI_LEVELS=[0.90,0.95,0.99]; let CI_MARKS=[];
    const ciMarkersPlugin={
      id:'ciMarkersT',
      afterDatasetsDraw(chart){
        if(!CI_MARKS.length) return;
        const {ctx, chartArea:{top,bottom}, scales:{x,y}}=chart;
        ctx.save(); ctx.strokeStyle=BLUE; ctx.fillStyle=BLUE; ctx.lineWidth=2;
        const bottomPix=y.getPixelForValue(0);
        const topPix=top+(bottom-top)*0.14;
        const arrowYs=[top+(bottom-top)*0.24, top+(bottom-top)*0.32, top+(bottom-top)*0.40];
        function drawArrow(x1,y0,x2){ ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x2,y0); ctx.stroke();
          const h=6; ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x1+h,y0-h); ctx.lineTo(x1+h,y0+h); ctx.closePath(); ctx.fill();
          ctx.beginPath(); ctx.moveTo(x2,y0); ctx.lineTo(x2-h,y0-h); ctx.lineTo(x2-h,y0+h); ctx.closePath(); ctx.fill();
        }
        ctx.textAlign='center'; ctx.textBaseline='bottom';
        ctx.font='12px "Noto Sans KR", system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        CI_MARKS.forEach((m,i)=>{
          const xl=x.getPixelForValue(-m.z), xr=x.getPixelForValue(+m.z);
          ctx.beginPath(); ctx.moveTo(xl,bottomPix); ctx.lineTo(xl,topPix); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(xr,bottomPix); ctx.lineTo(xr,topPix); ctx.stroke();
          const yArrow=arrowYs[i]; drawArrow(xl+2,yArrow,xr-2);
          ctx.fillText(m.label,(xl+xr)/2,yArrow-4);
        });
        ctx.restore();
      }
    };

    /* ===== 데이터 유틸 ===== */
    function buildCurve(v,xmin,xmax){
      const n=1401, step=(xmax-xmin)/(n-1), arr=[];
      for(let i=0;i<n;i++){ const x=xmin+i*step; arr.push({x,y:pdfT(x,v)}); }
      return arr;
    }
    function makeShade(base,pred){
      return base.map(p=>({x:p.x,y: pred(p.x)? p.y : null}));
    }

    /* ===== 초기 세팅: CI_MARKS를 '먼저' 계산해 차트 생성 ===== */
    const dfInput=document.getElementById('dfValue');
    const tInput =document.getElementById('tValue');
    const tailSel=document.getElementById('tailType');

    const v0=parseInt(dfInput.value,10);
    const t0=Number(tInput.value);

    // 1) 초기 신뢰구간 임계값을 먼저 계산해 CI_MARKS에 세팅 (← 핵심)
    CI_MARKS = CI_LEVELS.map(L=>{
      const c=invCdfT((1+L)/2, v0);
      return { z:c, label:`${(L*100).toFixed(0)}% 신뢰구간 (±${c.toFixed(3)})` };
    });

    // 2) 도메인/데이터
    const maxCrit0=Math.max(...CI_MARKS.map(m=>m.z));
    const need0=Math.max(Math.abs(t0), maxCrit0);
    const xmax0=Math.min(80, Math.max(4.5, need0*1.2)), xmin0=-xmax0;
    const base0=buildCurve(v0,xmin0,xmax0);
    const shade0=makeShade(base0, x=> Math.abs(x) >= Math.abs(t0));

    Chart.register(ciMarkersPlugin);

    const chart = new Chart(document.getElementById('chart'), {
      type:'line',
      data:{ datasets:[
        { label:'t_ν 밀도 f(t)', data: base0, parsing:false, borderWidth:2, pointRadius:0, tension:0.15, borderColor: BLUE },
        { label:'p-value 영역', data: shade0, parsing:false, borderWidth:0, pointRadius:0, fill:'origin', backgroundColor: SHADE }
      ]},
      options:{
        responsive:true,
        animation:{duration:200},
        plugins:{
          legend:{display:true},
          tooltip:{mode:'index', intersect:false, callbacks:{
            label:(c)=> c.datasetIndex===0 ? ` f(t) ≈ ${c.parsed.y.toFixed(5)}` : null
          }}
        },
        scales:{
          x:{type:'linear', title:{display:true,text:'t'}, suggestedMin:xmin0, suggestedMax:xmax0},
          y:{title:{display:true,text:'밀도 f(t)'}}
        }
      }
    });

    /* ===== p-value 박스 초기값 표시 ===== */
    const pBoxValue=document.getElementById('pBoxValue');
    const pBoxMeta =document.getElementById('pBoxMeta');
    (function initPbox(){
      const tabs=Math.abs(t0);
      const p0=2*(1 - cdfT(tabs, v0));
      pBoxValue.textContent = formatProb(p0);
      pBoxMeta.textContent  = `양측, |t|=${tabs.toFixed(3)} (ν=${v0}) → P(|T_ν| ≥ ${tabs.toFixed(3)})`;
    })();

    /* ===== 업데이트 ===== */
    function update(){
      const v=parseInt(dfInput.value,10);
      const t=Number(tInput.value);
      const tail=tailSel.value;

      if(!Number.isFinite(v)||v<1){
        pBoxValue.textContent='—'; pBoxMeta.textContent='유효한 자유도(ν≥1)를 입력하세요';
        chart.data.datasets[0].data=[]; chart.data.datasets[1].data=[]; chart.update(); return;
      }
      if(!Number.isFinite(t)){
        pBoxValue.textContent='—'; pBoxMeta.textContent='유효한 t 값을 입력하세요';
        chart.data.datasets[1].data=[]; chart.update(); return;
      }

      // CI & 도메인
      CI_MARKS = CI_LEVELS.map(L=>{
        const c=invCdfT((1+L)/2, v);
        return { z:c, label:`${(L*100).toFixed(0)}% 신뢰구간 (±${c.toFixed(3)})` };
      });
      const maxCrit=Math.max(...CI_MARKS.map(m=>m.z));
      const need=Math.max(Math.abs(t), maxCrit);
      const xmax=Math.min(80, Math.max(4.5, need*1.2)), xmin=-xmax;

      if(chart.options.scales.x.suggestedMax !== xmax){
        chart.options.scales.x.suggestedMin=xmin;
        chart.options.scales.x.suggestedMax=xmax;
        chart.data.datasets[0].data=buildCurve(v,xmin,xmax);
      }else{
        const base=chart.data.datasets[0].data;
        for(let i=0;i<base.length;i++) base[i].y=pdfT(base[i].x,v);
      }

      // 음영 & p-value
      const base=chart.data.datasets[0].data;
      let pval, meta;
      if (tail==='two'){
        const tabs=Math.abs(t);
        pval=2*(1 - cdfT(tabs,v));
        chart.data.datasets[1].data = makeShade(base, x=> Math.abs(x) >= tabs);
        meta=`양측, |t|=${tabs.toFixed(3)} (ν=${v}) → P(|T_ν| ≥ ${tabs.toFixed(3)})`;
      } else if (tail==='right'){
        pval=1 - cdfT(t,v);
        chart.data.datasets[1].data = makeShade(base, x=> x >= t);
        meta=`우측, t=${t.toFixed(3)} (ν=${v}) → P(T_ν ≥ ${t.toFixed(3)})`;
      } else {
        pval=cdfT(t,v);
        chart.data.datasets[1].data = makeShade(base, x=> x <= t);
        meta=`좌측, t=${t.toFixed(3)} (ν=${v}) → P(T_ν ≤ ${t.toFixed(3)})`;
      }

      // 고정 색상 유지
      chart.data.datasets[0].borderColor = BLUE;
      chart.data.datasets[1].backgroundColor = SHADE;

      pBoxValue.textContent = formatProb(pval);
      pBoxMeta.textContent  = meta;

      chart.update();
    }

    [dfInput, tInput, tailSel].forEach(el=>el.addEventListener('input', update));
  </script>
</body>
</html>
