<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>계량경제학 · t-분포(표식 & p-value)</title>

  <!-- 공통 스타일 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end;margin-bottom:16px}
    .ctrl{background:var(--panel);border:1px solid rgba(255,255,255,.08);padding:12px 14px;border-radius:12px;box-shadow: var(--shadow)}
    .ctrl label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    .ctrl select,.ctrl input{width:180px;background:var(--panel);color:var(--text);border:1px solid rgba(255,255,255,.15);border-radius:8px;padding:8px 10px}
    .ctrl select:focus,.ctrl input:focus{outline:none;box-shadow:0 0 0 4px var(--ring)}
    select option{background:var(--panel);color:var(--text)}
    @media (prefers-color-scheme: light){ select option{background:#fff;color:#0f172a} }
    .stat{min-width:240px;display:flex;flex-direction:column;gap:4px;background:linear-gradient(180deg, rgba(106,169,255,.12), rgba(106,169,255,.06)), var(--panel);border:1px solid rgba(106,169,255,.35)}
    .stat .label{font-size:12px;color:var(--muted)}
    .stat .value{font-variant-numeric:tabular-nums;font-weight:700;font-size:26px;line-height:1.1}
    .stat .meta{font-size:12px;color:var(--muted)}
    canvas{background:var(--panel);border-radius:18px;box-shadow:var(--shadow);padding:10px}
    .hint{color:var(--muted);font-size:14px;margin-top:8px}
  </style>
</head>
<body>
  <header class="site-header">
    <h1>t-분포 시각화</h1>
    <p class="subtitle">스튜던트 t (자유도 ν) · 신뢰구간 표식(선/화살표) · p-value 계산</p>
  </header>

  <main class="grid" style="grid-template-columns:1fr;">
    <section class="card">
      <!-- 컨트롤 -->
      <div class="controls">
        <div class="ctrl">
          <label for="dfValue">자유도 ν</label>
          <input id="dfValue" type="number" step="1" min="1" value="10" />
        </div>

        <div class="ctrl">
          <label for="tValue">t-통계량 (p-value 계산)</label>
          <input id="tValue" type="number" step="0.01" value="2.228" inputmode="decimal" />
        </div>

        <div class="ctrl">
          <label for="tailType">검정 방향</label>
          <select id="tailType">
            <option value="two" selected>양측검정 (two-tailed)</option>
            <option value="right">우측검정 (right-tailed)</option>
            <option value="left">좌측검정 (left-tailed)</option>
          </select>
        </div>

        <!-- p-value 박스 -->
        <div class="ctrl stat" id="pBox" aria-live="polite">
          <div class="label">p-value</div>
          <div class="value" id="pBoxValue">—</div>
          <div class="meta" id="pBoxMeta">—</div>
        </div>
      </div>

      <!-- 그래프 -->
      <canvas id="chart" height="120"></canvas>

      <div class="hint">
        ※ CDF는 정규화 불완전 베타함수(연분수; Lentz) 기반, PDF는 Γ함수(Lanczos) 기반으로 계산합니다.
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
  </footer>

  <script src="../../assets/site.js"></script>
  <script>
    // ========== 기본 설정: 자동 팔레트 비활성화(초기 빨간색 플래시 방지) ==========
    Chart.defaults.plugins.colors = Chart.defaults.plugins.colors || {};
    Chart.defaults.plugins.colors.enabled = false;

    // ====================== 유틸/색상 ======================
    const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
    function formatProb(p){ if(!Number.isFinite(p)) return '—'; p=clamp(p,0,1); return p<1e-6? p.toExponential(2):p.toFixed(6); }
    function primaryFill(alpha=0.2){
      const css=getComputedStyle(document.documentElement);
      const prim=(css.getPropertyValue('--primary')||'#6aa9ff').trim();
      if(prim.startsWith('#')){
        const hex=prim.length===4?('#'+prim[1]+prim[1]+prim[2]+prim[2]+prim[3]+prim[3]):prim;
        const aa=Math.round(alpha*255).toString(16).padStart(2,'0');
        return hex+aa; // #RRGGBBAA
      }
      if (prim.startsWith('rgb(')) return prim.replace('rgb(','rgba(').replace(')',`, ${alpha})`);
      if (prim.startsWith('hsl(')) return prim.replace('hsl(','hsla(').replace(')',`, ${alpha})`);
      return prim;
    }

    // ====================== Γ, Beta, 정규화 불완전 베타 ======================
    function logGamma(z){
      const p=[0.99999999999980993,676.5203681218851,-1259.1392167224028,771.32342877765313,-176.61502916214059,12.507343278686905,-0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
      const g=7;
      if(z<0.5){ return Math.log(Math.PI)-Math.log(Math.sin(Math.PI*z))-logGamma(1-z); }
      z-=1; let x=p[0]; for(let i=1;i<p.length;i++) x+=p[i]/(z+i);
      const t=z+g+0.5; return 0.5*Math.log(2*Math.PI)+(z+0.5)*Math.log(t)-t+Math.log(x);
    }
    function betacf(a,b,x){
      const MAXIT=200,EPS=3e-7,FPMIN=1e-300; let qab=a+b,qap=a+1,qam=a-1; let c=1,d=1-qab*x/qap; if(Math.abs(d)<FPMIN)d=FPMIN; d=1/d; let h=d;
      for(let m=1;m<=MAXIT;m++){ const m2=2*m;
        let aa=m*(b-m)*x/((qam+m2)*(a+m2)); d=1+aa*d; if(Math.abs(d)<FPMIN)d=FPMIN; d=1/d; c=1+aa/c; if(Math.abs(c)<FPMIN)c=FPMIN; h*=d*c;
        aa=-(a+m)*(qab+m)*x/((a+m2)*(qap+m2)); d=1+aa*d; if(Math.abs(d)<FPMIN)d=FPMIN; d=1/d; c=1+aa/c; if(Math.abs(c)<FPMIN)c=FPMIN; const del=d*c; h*=del;
        if(Math.abs(del-1)<EPS) break;
      } return h;
    }
    function incbetaReg(x,a,b){
      if(x<=0) return 0; if(x>=1) return 1;
      const lnBt = logGamma(a+b)-logGamma(a)-logGamma(b) + a*Math.log(x)+b*Math.log(1-x);
      const bt = Math.exp(lnBt);
      if(x < (a+1)/(a+b+2)) return bt*betacf(a,b,x)/a;
      return 1 - (bt*betacf(b,a,1-x)/b);
    }

    // ====================== t-분포 PDF/CDF/역CDF ======================
    function pdfT(x,v){
      const lnC = logGamma((v+1)/2)-logGamma(v/2)-0.5*(Math.log(v)+Math.log(Math.PI));
      const lnK = -((v+1)/2)*Math.log(1 + (x*x)/v);
      return Math.exp(lnC+lnK);
    }
    function cdfT(x,v){
      const a=v/2, b=0.5, t=v/(v+x*x), I=incbetaReg(t,a,b);
      return (x>=0)? 1-0.5*I : 0.5*I;
    }
    function invCdfT(p,v){
      if(p<=0) return -Infinity; if(p>=1) return Infinity; if(p===0.5) return 0;
      const sign = p<0.5? -1: 1, target = p<0.5? 1-p: p;
      let lo=0, hi=1; while(cdfT(hi,v)<target){ hi*=2; if(hi>1e6) break; }
      for(let i=0;i<80;i++){ const mid=(lo+hi)/2, F=cdfT(mid,v); if(F<target) lo=mid; else hi=mid; }
      return sign*(lo+hi)/2;
    }

    // ====================== 신뢰구간 표식 플러그인 ======================
    const CI_LEVELS=[0.90,0.95,0.99]; let CI_MARKS=[];
    const ciMarkersPlugin={
      id:'ciMarkersT',
      afterDatasetsDraw(chart){
        if(!CI_MARKS.length) return;
        const {ctx, chartArea:{top,bottom}, scales:{x,y}}=chart;
        const css=getComputedStyle(document.documentElement);
        const color=(css.getPropertyValue('--primary')||'#6aa9ff').trim();
        ctx.save(); ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=2;
        const bottomPix=y.getPixelForValue(0);
        const topPix=top+(bottom-top)*0.14;
        const arrowYs=[top+(bottom-top)*0.24, top+(bottom-top)*0.32, top+(bottom-top)*0.40];
        function drawArrow(x1,y0,x2){ ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x2,y0); ctx.stroke();
          const h=6; ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x1+h,y0-h); ctx.lineTo(x1+h,y0+h); ctx.closePath(); ctx.fill();
          ctx.beginPath(); ctx.moveTo(x2,y0); ctx.lineTo(x2-h,y0-h); ctx.lineTo(x2-h,y0+h); ctx.closePath(); ctx.fill();
        }
        ctx.textAlign='center'; ctx.textBaseline='bottom';
        ctx.font='12px "Noto Sans KR", system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        CI_MARKS.forEach((m,i)=>{
          const xl=x.getPixelForValue(-m.z), xr=x.getPixelForValue(+m.z);
          ctx.beginPath(); ctx.moveTo(xl,bottomPix); ctx.lineTo(xl,topPix); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(xr,bottomPix); ctx.lineTo(xr,topPix); ctx.stroke();
          const yArrow=arrowYs[i]; drawArrow(xl+2,yArrow,xr-2);
          ctx.fillText(m.label,(xl+xr)/2,yArrow-4);
        });
        ctx.restore();
      }
    };

    // ====================== 도메인/데이터 생성 ======================
    function buildCurve(v, xmin, xmax){
      const n=1401, step=(xmax-xmin)/(n-1), curve=[];
      for(let i=0;i<n;i++){ const x=xmin+i*step; curve.push({x, y: pdfT(x,v)}); }
      return curve;
    }
    function makeShadeFrom(base, pred){
      return base.map(p => ({x:p.x, y: pred(p.x) ? p.y : null}));
    }

    // ====================== 초기 상태(곡선/음영 먼저 계산) ======================
    const dfInput=document.getElementById('dfValue');
    const tInput =document.getElementById('tValue');
    const tailSel=document.getElementById('tailType');

    const v0 = parseInt(dfInput.value,10);
    const t0 = Number(tInput.value);
    const Ls = [0.90,0.95,0.99];
    const marks0 = Ls.map(L=> invCdfT((1+L)/2, v0));
    const need0 = Math.max(Math.abs(t0), ...marks0);
    const xmax0 = Math.min(80, Math.max(4.5, need0*1.2));
    const xmin0 = -xmax0;

    const base0 = buildCurve(v0, xmin0, xmax0);
    const shadeColor = primaryFill(0.2);

    // 두 꼬리(양측) 기준으로 음영 초기화 (정규 페이지와 동일 로직)
    const shade0 = makeShadeFrom(base0, x => Math.abs(x) >= Math.abs(t0));

    // ====================== 차트 생성 (데이터/색상 모두 채워서 생성) ======================
    Chart.register(ciMarkersPlugin);

    const chart = new Chart(document.getElementById('chart'), {
      type: 'line',
      data: { datasets: [
        { label:'t_ν 밀도 f(t)', data: base0, parsing:false, borderWidth:2, pointRadius:0, tension:0.15 },
        { label:'p-value 영역', data: shade0, parsing:false, borderWidth:0, pointRadius:0, fill:'origin', hidden:false,
          backgroundColor: shadeColor } // 초기부터 고정 색상
      ]},
      options: {
        responsive:true,
        animation:{ duration:200 },
        plugins:{
          legend:{ display:true },
          tooltip:{ mode:'index', intersect:false, callbacks:{
            label:(c)=> c.datasetIndex===0 ? ` f(t) ≈ ${c.parsed.y.toFixed(5)}` : null
          }}
        },
        scales:{
          x:{ type:'linear', title:{display:true,text:'t'}, suggestedMin:xmin0, suggestedMax:xmax0 },
          y:{ title:{display:true,text:'밀도 f(t)'} }
        }
      }
    });

    // ====================== UI & 업데이트 ======================
    const pBoxValue=document.getElementById('pBoxValue');
    const pBoxMeta =document.getElementById('pBoxMeta');

    function update(){
      const v=parseInt(dfInput.value,10);
      const t=Number(tInput.value);
      const tail=tailSel.value;

      if(!Number.isFinite(v)||v<1){
        pBoxValue.textContent='—'; pBoxMeta.textContent='유효한 자유도(ν≥1)를 입력하세요';
        chart.data.datasets[0].data=[]; chart.data.datasets[1].data=[]; chart.update(); return;
      }
      if(!Number.isFinite(t)){
        pBoxValue.textContent='—'; pBoxMeta.textContent='유효한 t 값을 입력하세요';
        chart.data.datasets[1].data=[]; chart.update(); return;
      }

      // 신뢰구간 임계값/도메인
      CI_MARKS = CI_LEVELS.map(L => {
        const c = invCdfT((1+L)/2, v);
        return { z:c, label:`${(L*100).toFixed(0)}% 신뢰구간 (±${c.toFixed(3)})` };
      });
      const maxCrit = Math.max(...CI_MARKS.map(m=>m.z));
      const need = Math.max(Math.abs(t), maxCrit);
      const xmax = Math.min(80, Math.max(4.5, need*1.2));
      const xmin = -xmax;

      // 곡선 갱신(도메인 바뀌면 재생성)
      const domChanged = (chart.options.scales.x.suggestedMax !== xmax);
      if(domChanged){
        chart.options.scales.x.suggestedMin = xmin;
        chart.options.scales.x.suggestedMax = xmax;
        chart.data.datasets[0].data = buildCurve(v, xmin, xmax);
      }else{
        // y만 갱신
        const base=chart.data.datasets[0].data;
        for(let i=0;i<base.length;i++) base[i].y = pdfT(base[i].x, v);
      }

      // 음영 & p-value (정규 페이지와 동일 로직)
      const base = chart.data.datasets[0].data;
      let pval, meta;

      if (tail==='two'){
        const tabs = Math.abs(t);
        pval = 2*(1 - cdfT(tabs, v));
        chart.data.datasets[1].data = makeShadeFrom(base, x => Math.abs(x) >= tabs);
        meta = `양측, |t|=${tabs.toFixed(3)} (ν=${v}) → P(|T_ν| ≥ ${tabs.toFixed(3)})`;
      } else if (tail==='right'){
        pval = 1 - cdfT(t, v);
        chart.data.datasets[1].data = makeShadeFrom(base, x => x >= t);
        meta = `우측, t=${t.toFixed(3)} (ν=${v}) → P(T_ν ≥ ${t.toFixed(3)})`;
      } else {
        pval = cdfT(t, v);
        chart.data.datasets[1].data = makeShadeFrom(base, x => x <= t);
        meta = `좌측, t=${t.toFixed(3)} (ν=${v}) → P(T_ν ≤ ${t.toFixed(3)})`;
      }

      pBoxValue.textContent = formatProb(pval);
      pBoxMeta.textContent  = meta;

      chart.update();
    }

    [dfInput, tInput, tailSel].forEach(el => el.addEventListener('input', update));
    // 초기 p-value도 세팅
    (function initPbox(){
      const v=parseInt(dfInput.value,10);
      const tabs=Math.abs(Number(tInput.value));
      const p0 = 2*(1 - cdfT(tabs, v));
      pBoxValue.textContent = formatProb(p0);
      pBoxMeta.textContent  = `양측, |t|=${tabs.toFixed(3)} (ν=${v}) → P(|T_ν| ≥ ${tabs.toFixed(3)})`;
      // CI_MARKS도 초기화
      CI_MARKS = CI_LEVELS.map(L => {
        const c = invCdfT((1+L)/2, v);
        return { z:c, label:`${(L*100).toFixed(0)}% 신뢰구간 (±${c.toFixed(3)})` };
      });
    })();
  </script>
</body>
</html>
