<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>완전보완재(레온티에프 효용함수)</title>
  <meta name="description" content="완전보완재 U(x,y)=min(x/α, y/β)에서 α,β·가격·소득을 입력해 최적선택점을 시각화하고 ICC(소득–소비 곡선)를 선으로 표시합니다. 분수/표현식 입력 지원." />

  <!-- 공통: 폰트/스타일 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />
  <link rel="stylesheet" href="../../assets/mobile.css" media="(max-width: 768px)" />

  <!-- 차트 (버전 고정) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" defer></script>

  <style>
    /* ===== 레이아웃 / 공통 ===== */
    main.grid { grid-template-columns: minmax(300px,460px) 1fr; }
    .controls { display:flex; flex-direction:column; gap:10px; }
    .row { display:grid; grid-template-columns: 1fr auto; gap:.5rem; align-items:center; }

    /* 가격 슬라이더용 컴팩트 행(라벨 · 슬라이더 · 값) */
    .row-compact { grid-template-columns: auto 1fr auto; }
    .mini-val { color: var(--muted); font-size: .9rem; min-width: 4ch; text-align: right; }

    .controls input[type="range"],
    .controls input[type="text"],
    .controls button,
    .controls a {
      border:1px solid var(--muted);
      background:var(--panel);
      color:var(--text);
      padding:.5rem .75rem;
      border-radius:.5rem;
      box-shadow: var(--shadow);
      font:inherit;
    }
    .controls input[type="range"]{ padding:0; }
    .controls input:focus-visible,
    .controls button:focus-visible,
    .controls a:focus-visible,
    canvas:focus-visible { outline:0; box-shadow:0 0 0 4px var(--ring); }
    .invalid{ border-color:var(--ring); }

    /* ===== 차트 컨테이너 ===== */
    .chart-wrap{ position:relative; height:460px; }

    /* 수동 범례(간결한 3개 항목만 표기) */
    .legend { display:flex; gap:12px; flex-wrap:wrap; color:var(--muted); font-size:.92rem; }
    .badge { display:inline-flex; align-items:center; gap:.4rem; }
    .swatch { width:.75rem; height:.75rem; border-radius:50%; border:1px solid var(--muted); background:var(--panel); }

    /* 숫자/텍스트 블럭 */
    .nums { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:.25rem .75rem; }
    .nums dt{ color:var(--muted); }
    .nums dd{ margin:0; font-weight:600; }

    .muted{ color:var(--muted); }
    [hidden]{ display:none !important; }

    details.reinit { margin-top:.5rem; border:1px dashed var(--muted); border-radius:.5rem; padding:.5rem .75rem; }
    details.reinit > summary { cursor:pointer; font-weight:600; color:var(--muted); }
    .subgrid { display:grid; grid-template-columns: 1fr auto; gap:.5rem; align-items:center; margin-top:.5rem; }

    /* α,β 입력 수식형 */
    .formula { display:flex; align-items:center; flex-wrap:wrap; gap:.5rem .6rem; font-weight:700; }
    .formula kbd { font-family:inherit; background:transparent; padding:0; }
    .frac { display:inline-flex; align-items:center; gap:.35rem; }
    .frac-input { width:6ch; text-align:center; padding:.35rem .5rem; }
    .formula-note { font-weight:600; color:var(--muted); }
  </style>
</head>
<body>
  <header class="site-header">
    <h1>완전보완재(레온티에프 효용함수)</h1>
    <p class="subtitle">U(x,y)=min(x/α, y/β), 예산: pₓx + pᵧy = M</p>
  </header>

  <main class="grid">
    <!-- (1) 시작 화면 -->
    <section class="card controls" id="init-card" aria-labelledby="init-title">
      <h2 id="init-title">초기값 입력 후 그리기 (분수/표현식 가능)</h2>

      <!-- α,β 수식형 입력 -->
      <div class="formula" aria-label="효용함수와 α,β 입력">
        <span>U(x,y) = min(</span>
        <span class="frac">x / <input id="i-alpha" class="frac-input" type="text" inputmode="text" value="2" aria-label="α (x 쪽)" placeholder="예: 2, 3/2"></span>
        <span>,</span>
        <span class="frac">y / <input id="i-beta" class="frac-input" type="text" inputmode="text" value="1" aria-label="β (y 쪽)" placeholder="예: 1, 1/3"></span>
        <span>)</span>
      </div>
      <p class="formula-note">※ α,β는 <kbd>min(x/α , y/β)</kbd>의 분모에 직접 입력합니다.</p>

      <div class="row">
        <label for="i-px">가격 p<sub>x</sub></label>
        <input id="i-px" type="text" inputmode="text" value="10" placeholder="예: 10, 3/2">
      </div>
      <div class="row">
        <label for="i-py">가격 p<sub>y</sub></label>
        <input id="i-py" type="text" inputmode="text" value="10" placeholder="예: 10, 1/3">
      </div>
      <div class="row">
        <label for="i-M">소득 M</label>
        <input id="i-M" type="text" inputmode="text" value="120" placeholder="예: 60, 120/2">
      </div>

      <button id="drawBtn" style="margin-top:.5rem;">그리기</button>
      <p class="muted" style="margin-top:6px;">※ 그리기 후 α,β·가격은 슬라이더로 미세 조정, M은 재입력으로만 변경(ICC는 선만 표시).</p>
      <p class="muted" id="initStatus" aria-live="polite"></p>
    </section>

    <!-- (2) 컨트롤 카드 -->
    <section class="card controls" id="ctl-card" aria-labelledby="ctl-title" hidden>
      <h2 id="ctl-title">값 조정</h2>

      <!-- α,β 수식형 즉시 편집 -->
      <div class="formula" aria-label="α,β 즉시 편집">
        <span>U(x,y) = min(</span>
        <span class="frac">x / <input id="alphaNum" class="frac-input" type="text" inputmode="text" placeholder="예: 2"></span>
        <span>,</span>
        <span class="frac">y / <input id="betaNum"  class="frac-input" type="text" inputmode="text" placeholder="예: 1"></span>
        <span>)</span>
      </div>

      <!-- α,β 슬라이더 -->
      <div class="row">
        <label for="alpha">α (비율)</label>
        <input id="alpha" type="range">
      </div>
      <div class="row">
        <label for="beta">β (비율)</label>
        <input id="beta" type="range">
      </div>

      <!-- 가격 슬라이더 (한 줄: 라벨 · 슬라이더 · 작은 값) -->
      <div class="row row-compact">
        <label for="px">가격 p<sub>x</sub></label>
        <input id="px" type="range">
        <small class="mini-val" id="pxVal">–</small>
      </div>

      <div class="row row-compact">
        <label for="py">가격 p<sub>y</sub></label>
        <input id="py" type="range">
        <small class="mini-val" id="pyVal">–</small>
      </div>

      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem; align-items:center;">
        <button id="refitBtn" title="현재 값 기준으로 축 범위를 다시 맞춥니다.">축 재설정</button>
        <span class="muted">M은 슬라이더 없이 고정(재입력으로만 변경). ICC는 y=(β/α)x 직선.</span>
      </div>

      <!-- (2-1) 파라미터 재입력 (M 포함) -->
      <details class="reinit" id="reinitBox">
        <summary>파라미터 재입력</summary>
        <div class="subgrid"><label for="ri-alpha">α (새 기준)</label><input id="ri-alpha" type="text" inputmode="text" placeholder="예: 2"></div>
        <div class="subgrid"><label for="ri-beta">β (새 기준)</label><input id="ri-beta" type="text" inputmode="text" placeholder="예: 1"></div>
        <div class="subgrid"><label for="ri-px">p<sub>x</sub> (새 기준)</label><input id="ri-px" type="text" inputmode="text" placeholder="예: 10"></div>
        <div class="subgrid"><label for="ri-py">p<sub>y</sub> (새 기준)</label><input id="ri-py" type="text" inputmode="text" placeholder="예: 10"></div>
        <div class="subgrid"><label for="ri-M">M (새 기준)</label><input id="ri-M" type="text" inputmode="text" placeholder="예: 120"></div>
        <div style="margin-top:.5rem; display:flex; gap:.5rem;">
          <button id="applyReinit">작용</button>
          <button type="button" id="cancelReinit">취소</button>
        </div>
        <p class="muted" style="margin-top:.25rem;">적용 시 슬라이더 범위·축이 새 기준으로 재설정되고, 최적점/ICC/무차별곡선이 다시 그려집니다.</p>
      </details>

      <dl class="nums" aria-live="polite" style="margin-top:.5rem;">
        <dt>x* (최적)</dt><dd id="xStar">–</dd>
        <dt>y* (최적)</dt><dd id="yStar">–</dd>
        <dt>t* (=M/(αpₓ+βpᵧ))</dt><dd id="tStar">–</dd>
        <dt>x절편 (M/p<sub>x</sub>)</dt><dd id="xInt">–</dd>
        <dt>y절편 (M/p<sub>y</sub>)</dt><dd id="yInt">–</dd>
      </dl>
      <p id="statusMsg" class="muted" aria-live="polite"></p>
    </section>

    <!-- (3) 차트 카드 -->
    <section class="card" id="chart-card" hidden aria-labelledby="chart-title">
      <h2 id="chart-title">예산선 · ICC · 무차별곡선 · 최적점</h2>

      <!-- 간결한 수동 범례 -->
      <div class="legend" aria-hidden="true" style="margin-bottom:8px;">
        <span class="badge"><span class="swatch" style="background:var(--text)"></span>예산선</span>
        <span class="badge"><span class="swatch" style="background:var(--primary)"></span>무차별곡선</span>
        <span class="badge"><span class="swatch" style="background:#e74c3c; border-style:dashed;"></span>ICC</span>
      </div>

      <div class="chart-wrap">
        <canvas id="leoChart" data-responsive aria-label="예산선, ICC, 무차별곡선, 최적점"></canvas>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
    <small>© <span id="year"></span> aries0401-svc</small>
  </footer>

  <!-- 공통 스크립트 -->
  <script src="../../assets/mobile-init.js"></script>
  <script src="../../assets/site.js"></script>

  <!-- 페이지 전용 스크립트 (IIFE로 감싸 전역 재선언 방지) -->
  <script>
  (() => {
    "use strict";

    /* ──────────────────────────────────────────────────────────────────────────
       1) 안전한 사칙연산 파서 (셔닝야드) — 분수/표현식 입력 지원
    ─────────────────────────────────────────────────────────────────────────── */
    function evalExpr(raw){
      if(typeof raw!=='string') return NaN;
      let s = raw.trim(); if(!s) return NaN;
      s = s.replace(/\s+/g,'')
           .replace(/[−–—]/g,'-')
           .replace(/[×·x]/g,'*')
           .replace(/[÷⁄]/g,'/');
      const tokens=[], isDigit=c=>/[0-9.]/.test(c); let i=0, prev=null;
      while(i<s.length){ const c=s[i];
        if(isDigit(c) || (c==='-' && (prev===null || /[+\-*/(]/.test(prev)) && isDigit(s[i+1]))){
          let j=i+1; while(j<s.length && /[0-9.]/.test(s[j])) j++; tokens.push(s.slice(i,j)); prev='n'; i=j; continue;
        }
        if('+-*/()'.includes(c)){ tokens.push(c); prev=c; i++; continue; }
        return NaN;
      }
      const out=[], op=[], prec={'+':1,'-':1,'*':2,'/':2};
      for(const t of tokens){
        if(t in prec){ while(op.length){ const k=op[op.length-1]; if((k in prec)&&prec[k]>=prec[t]) out.push(op.pop()); else break; } op.push(t); }
        else if(t==='('){ op.push(t); }
        else if(t===')'){ while(op.length && op[op.length-1]!=='(') out.push(op.pop()); if(!op.length) return NaN; op.pop(); }
        else out.push(t);
      }
      while(op.length){ const k=op.pop(); if(k==='('||k===')') return NaN; out.push(k); }
      const st=[]; for(const t of out){
        if(t in prec){
          const b=+st.pop(), a=+st.pop();
          if(!Number.isFinite(a)||!Number.isFinite(b)) return NaN;
          st.push(t==='+'?a+b:t==='-'?a-b:t==='*'?a*b:(b===0?NaN:a/b));
        } else {
          const v=+t; if(!Number.isFinite(v)) return NaN; st.push(v);
        }
      }
      if(st.length!==1) return NaN; const res=+st[0]; return Number.isFinite(res)?res:NaN;
    }
    function parseInput(el){ const v=evalExpr(el.value); el.classList.toggle('invalid', !Number.isFinite(v)); return v; }

    /* ──────────────────────────────────────────────────────────────────────────
       2) 유틸리티 / 전역 상태
    ─────────────────────────────────────────────────────────────────────────── */
    const $=(s)=>document.querySelector(s);
    function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    let C_TEXT, C_PRIMARY, C_MUTED; function loadColors(){ C_TEXT=cssVar('--text'); C_PRIMARY=cssVar('--primary'); C_MUTED=cssVar('--muted'); }
    const C_ICC = '#e74c3c';
    function fmt(v,d=2){ if(!Number.isFinite(v)) return (v===Infinity||v===-Infinity)?'\u221E':'–'; return (+v).toFixed(d); }
    function setRange(rangeEl, _unused, {min, max, step, value, decimals=2}){
      if(min===max){ max = min + (Math.abs(min)||1); }
      if(min>max){ const t=min; min=max; max=t; }
      rangeEl.min=min; rangeEl.max=max; rangeEl.step=step; rangeEl.value=+(+value).toFixed(decimals);
    }
    function setAroundAlphaBeta(rangeEl, base){
      const span=Math.max(0.2, Math.abs(base)*0.2);
      setRange(rangeEl, null, {min: base-span, max: base+span, step:0.01, value:base, decimals:2});
    }
    function setAroundPrice(rangeEl, base){
      const span=Math.max((Math.abs(base)||1)*0.5, 1);
      setRange(rangeEl, null, {min: base-span, max: base+span, step:0.05, value:base, decimals:2});
    }

    // 입력 엘리먼트 참조
    const iA=$('#i-alpha'), iB=$('#i-beta'), iPx=$('#i-px'), iPy=$('#i-py'), iM=$('#i-M');
    const drawBtn=$('#drawBtn'), initStatus=$('#initStatus');

    const ctlCard=$('#ctl-card'), chartCard=$('#chart-card');
    const alphaR=$('#alpha'), alphaN=$('#alphaNum');  // α 슬라이더/수식 입력
    const betaR=$('#beta'),  betaN=$('#betaNum');     // β 슬라이더/수식 입력
    const pxR=$('#px'), pxVal=$('#pxVal');
    const pyR=$('#py'), pyVal=$('#pyVal');

    const xStarEl=$('#xStar'), yStarEl=$('#yStar'), tStarEl=$('#tStar'), xIntEl=$('#xInt'), yIntEl=$('#yInt');
    const refitBtn=$('#refitBtn'), statusMsg=$('#statusMsg');

    const reinitBox=$('#reinitBox');
    const riA=$('#ri-alpha'), riB=$('#ri-beta'), riPx=$('#ri-px'), riPy=$('#ri-py'), riM=$('#ri-M');
    const applyReinit=$('#applyReinit'), cancelReinit=$('#cancelReinit');

    // 사용자가 입력한 원문 보존(텍스트칸)
    const lastExpr={ a:'', b:'', px:'', py:'', M:'' };
    function applyExprToNumberInputs(){
      if(alphaN){ alphaN.value = lastExpr.a || (+alphaR.value).toFixed(2); alphaN.dataset.mode='expr'; alphaN.classList.remove('invalid'); }
      if(betaN ){ betaN.value  = lastExpr.b || (+betaR.value).toFixed(2);  betaN.dataset.mode='expr';  betaN.classList.remove('invalid'); }
      // 가격(px, py)은 컨트롤에서 텍스트 입력을 제거했으므로 여기서 건드리지 않습니다.
    }

    // 축 범위 & 배경 IC 레벨
    let BASE_XMAX=1, BASE_YMAX=1;
    let IC_LEVELS = [];

    // 현재 파라미터(슬라이더 기준; M은 별도 보관)
    function params(){
      const a=+(+alphaR.value), b=+(+betaR.value), px=+(+pxR.value), py=+(+pyR.value);
      const M = +riM.dataset.currentM || +iM.dataset.currentM || parseInput(iM);
      return {a,b,px,py,M};
    }
    function syncUI(){
      const {px,py}=params();
      if(pxVal) pxVal.textContent = isNaN(px)?'–':(+px).toFixed(2);
      if(pyVal) pyVal.textContent = isNaN(py)?'–':(+py).toFixed(2);
    }

    /* ──────────────────────────────────────────────────────────────────────────
       3) 차트 생성 (기본 범례 비활성화)
    ─────────────────────────────────────────────────────────────────────────── */
    let leoChart;
    function createChart(){
      const canvas=document.getElementById('leoChart'); if(!canvas) return;
      const ctx=canvas.getContext('2d');

      leoChart=new Chart(ctx,{
        type:'line',
        data:{ datasets:[
          {label:'예산선', data:[], borderColor:C_TEXT, borderWidth:2, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},                       // 0
          {label:'ICC', data:[], borderColor:C_ICC,   borderWidth:1.8, borderDash:[3,3], fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},     // 1
          {label:'무차별곡선(최적)', data:[], borderColor:C_PRIMARY, borderWidth:2.6, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},       // 2
          // 3..7 : 무차별곡선(배경) 5개
          {label:'무차별곡선', data:[], borderColor:C_PRIMARY, borderWidth:1.4, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},              // 3
          {label:'무차별곡선', data:[], borderColor:C_PRIMARY, borderWidth:1.4, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},              // 4
          {label:'무차별곡선', data:[], borderColor:C_PRIMARY, borderWidth:1.4, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},              // 5
          {label:'무차별곡선', data:[], borderColor:C_PRIMARY, borderWidth:1.4, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},              // 6
          {label:'무차별곡선', data:[], borderColor:C_PRIMARY, borderWidth:1.4, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},              // 7
          // 8: 최적점
          {label:'최적점', data:[], parsing:false, showLine:false, pointRadius:5, pointHoverRadius:6, pointBackgroundColor:C_PRIMARY, pointBorderColor:C_TEXT, pointBorderWidth:1.5, type:'scatter'},
          // 9,10: 투영선
          {label:'', data:[], borderColor:C_PRIMARY, borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false},      // 9
          {label:'', data:[], borderColor:C_PRIMARY, borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, pointHoverRadius:0, parsing:false}       // 10
        ]},
        options:{
          responsive:true, maintainAspectRatio:false,
          elements:{ point:{ radius:0, hoverRadius:0 }, line:{ tension:0, borderCapStyle:'butt', borderJoinStyle:'miter' } },
          animation:false, animations:{}, transitions:{ active:{ animation:{ duration:0 } } },
          scales:{
            x:{ type:'linear', title:{display:true,text:'x'}, grid:{ display:false }, ticks:{ display:true }, border:{ display:true, color:C_MUTED }, min:0, max:BASE_XMAX },
            y:{ type:'linear', title:{display:true,text:'y'}, grid:{ display:false }, ticks:{ display:true }, border:{ display:true, color:C_MUTED }, min:0, max:BASE_YMAX }
          },
          plugins:{ legend:{ display:false }, tooltip:{ mode:'nearest', intersect:false } }
        }
      });
    }

    function computeICLevels(a, b){
      const tAxesMax = Math.min(
        BASE_XMAX / Math.max(a,1e-9),
        BASE_YMAX / Math.max(b,1e-9)
      );
      const tTop = tAxesMax * 0.95;
      const fracs=[0.2,0.4,0.6,0.8,1.0];
      return fracs.map(f=>f*tTop);
    }

    function makeL(a,b,t){
      const kx=a*t, ky=b*t;
      const path=[];
      if(Number.isFinite(kx) && Number.isFinite(ky) && kx>=0 && ky>=0){
        const yCap=Math.min(ky, BASE_YMAX);
        path.push({x:kx, y:BASE_YMAX});
        path.push({x:kx, y:yCap});
        path.push({x:BASE_XMAX, y:yCap});
      }
      return path;
    }

    function recomputeAndDraw({fitAxes=false}={}){
      syncUI();
      const {a,b,px,py,M}=params();

      const validAB = (a>0 && b>0);
      const denom = a*px + b*py;
      const validT = validAB && Number.isFinite(M) && denom>0;

      const xInt = (px===0)? ((M===0)?0:((M>0)?Infinity:-Infinity)) : M/px;
      const yInt = (py===0)? ((M===0)?0:((M>0)?Infinity:-Infinity)) : M/py;

      let tStar=NaN, xStar=NaN, yStar=NaN;
      if(validT){ tStar = M/denom; xStar = a*tStar; yStar = b*tStar; }

      if(fitAxes){
        const xMaxCand = Math.max(0, Number.isFinite(xInt)?xInt:0, Number.isFinite(xStar)?xStar:0) * 1.3;
        const yMaxCand = Math.max(0, Number.isFinite(yInt)?yInt:0, Number.isFinite(yStar)?yStar:0) * 1.3;
        BASE_XMAX = (xMaxCand>0?xMaxCand:1);
        BASE_YMAX = (yMaxCand>0?yMaxCand:1);
        if(leoChart){ leoChart.options.scales.x.max=BASE_XMAX; leoChart.options.scales.y.max=BASE_YMAX; }
        if(validAB){ IC_LEVELS = computeICLevels(a,b); }
      }

      // 예산선
      let budget=[];
      if(px===0 && py===0){ budget=[]; }
      else if(px===0){ const y0=M/py; budget=[{x:0,y:y0},{x:BASE_XMAX,y:y0}]; }
      else if(py===0){ const x0=M/px; budget=[{x:x0,y:0},{x:x0,y:BASE_YMAX}]; }
      else { budget=[{x:0,y:yInt},{x:xInt,y:0}]; }

      // ICC: y=(β/α)x
      let icc=[];
      if(validAB){
        const slope = b/a;
        if(Number.isFinite(slope) && slope>=0){
          const xEnd = Math.min(BASE_XMAX, (a/b)*BASE_YMAX);
          icc = [{x:0,y:0},{x:xEnd,y:slope*xEnd}];
        }
      }

      // 무차별곡선
      let icAtOpt=[];
      if(validT && tStar>=0){ icAtOpt = makeL(a,b,tStar); }

      let icBackground=[[],[],[],[],[]];
      if(validAB && IC_LEVELS.length===5){
        icBackground = IC_LEVELS.map(t => makeL(a,b,t));
      }

      // 최적점/투영선
      let optPt=[], projY=[], projX=[];
      if(Number.isFinite(xStar)&&Number.isFinite(yStar)&&xStar>=0&&yStar>=0){
        optPt=[{x:xStar,y:yStar}];
        projY=[{x:0,y:yStar},{x:xStar,y:yStar}];
        projX=[{x:xStar,y:0},{x:xStar,y:yStar}];
      }

      if(leoChart){
        leoChart.data.datasets[0].data=budget;
        leoChart.data.datasets[1].data=icc;
        leoChart.data.datasets[2].data=icAtOpt;
        for(let i=0;i<5;i++){ leoChart.data.datasets[3+i].data = icBackground[i]; }
        leoChart.data.datasets[8].data=optPt;
        leoChart.data.datasets[9].data=projY;
        leoChart.data.datasets[10].data=projX;
        leoChart.update('none');
      }

      // 숫자/상태
      xStarEl.textContent=fmt(xStar);
      yStarEl.textContent=fmt(yStar);
      tStarEl.textContent=fmt(tStar,3);
      xIntEl.textContent =fmt(xInt);
      yIntEl.textContent =fmt(yInt);

      if(!(px===0 && py===0)){
        statusMsg.textContent = validT ? '' : '참고: α>0, β>0, αpₓ+βpᵧ>0, M 유한일 때만 t*와 내부해가 명확합니다. 현재는 예산선/ICC/무차별곡선만 표시될 수 있어요.';
      }else{
        statusMsg.textContent = 'pₓ=0, pᵧ=0이면 예산선이 정의되지 않습니다.';
      }
    }

    /* 텍스트-슬라이더 바인딩 (표현식 지원) — α, β 전용 */
    function bindPair(rangeEl, numberEl, decimals, onChange){
      rangeEl.addEventListener('input', ()=>{
        numberEl.value=(+rangeEl.value).toFixed(decimals);
        numberEl.dataset.mode='decimal';
        numberEl.classList.remove('invalid');
        onChange();
      });
      const commitFromText=()=>{
        const v=evalExpr(numberEl.value);
        if(!Number.isFinite(v)){ numberEl.classList.add('invalid'); return; }
        numberEl.classList.remove('invalid');
        const min=+rangeEl.min, max=+rangeEl.max;
        const vv=Math.min(Math.max(v,min),max);
        rangeEl.value=vv.toFixed(decimals);
        numberEl.dataset.mode='expr';
        onChange();
      };
      numberEl.addEventListener('change', commitFromText);
      numberEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); commitFromText(); } });
    }

    /* 초기 적용(슬라이더 범위/축/차트/이벤트) */
    function applyInitial(a0,b0,px0,py0,M0){
      // 슬라이더 범위
      setAroundAlphaBeta(alphaR, a0);
      setAroundAlphaBeta(betaR,  b0);
      setAroundPrice(pxR, px0);
      setAroundPrice(pyR, py0);

      // 축 초기 고정값
      const denom0=a0*px0+b0*py0; const t0 = (denom0>0)? (M0/denom0) : 0;
      const xInt0=(px0===0)?0:(M0/px0); const yInt0=(py0===0)?0:(M0/py0);
      const xStar0=(a0>0&&b0>0&&denom0>0)? a0*t0 : 0; const yStar0=(a0>0&&b0>0&&denom0>0)? b0*t0 : 0;
      const xMaxCand=Math.max(0, Number.isFinite(xInt0)?xInt0:0, Number.isFinite(xStar0)?xStar0:0)*1.3;
      const yMaxCand=Math.max(0, Number.isFinite(yInt0)?yInt0:0, Number.isFinite(yStar0)?yStar0:0)*1.3;
      BASE_XMAX=(xMaxCand>0?xMaxCand:1); BASE_YMAX=(yMaxCand>0?yMaxCand:1);

      // 화면 전환
      $('#init-card').hidden=true; ctlCard.hidden=false; chartCard.hidden=false;

      // 색/차트
      if(!leoChart){ loadColors(); createChart(); }

      // 배경 IC 레벨 초기화
      IC_LEVELS = computeICLevels(a0,b0);

      // 바인딩(1회)
      if(!alphaR.dataset.bound){
        bindPair(alphaR, alphaN, 2, ()=>recomputeAndDraw());
        bindPair(betaR,  betaN,  2, ()=>recomputeAndDraw());

        // 가격 슬라이더는 값 표시만(작은 숫자) 갱신
        pxR.addEventListener('input', ()=>recomputeAndDraw());
        pyR.addEventListener('input', ()=>recomputeAndDraw());

        alphaR.dataset.bound=betaR.dataset.bound=pxR.dataset.bound=pyR.dataset.bound='1';
      }

      // 첫 렌더 + 사용자 표현 반영
      recomputeAndDraw({fitAxes:true});
      applyExprToNumberInputs();
    }

    // 초기 그리기
    const draw = ()=>{
      const a0=parseInput(iA), b0=parseInput(iB), px0=parseInput(iPx), py0=parseInput(iPy), M0=parseInput(iM);
      if([a0,b0,px0,py0,M0].some(v=>!Number.isFinite(v))){ initStatus.textContent='표현식을 올바르게 입력해주세요.'; return; }
      initStatus.textContent='';
      lastExpr.a=iA.value.trim(); lastExpr.b=iB.value.trim(); lastExpr.px=iPx.value.trim(); lastExpr.py=iPy.value.trim(); lastExpr.M=iM.value.trim();
      iM.dataset.currentM = M0; // 현재 M 저장
      applyInitial(a0,b0,px0,py0,M0);
    };
    drawBtn.addEventListener('click', draw);

    // 재입력 박스 프리필
    reinitBox.addEventListener('toggle',(e)=>{
      if(e.target.open){
        const {a,b,px,py,M}=params();
        riA.value=isNaN(a)?'':(+a).toFixed(2);
        riB.value=isNaN(b)?'':(+b).toFixed(2);
        riPx.value=isNaN(px)?'':(+px).toFixed(2);
        riPy.value=isNaN(py)?'':(+py).toFixed(2);
        riM.value=isNaN(M)?'':(+M).toFixed(0);
      }
    });

    // 재입력 적용
    applyReinit.addEventListener('click', ()=>{
      const a0=parseInput(riA), b0=parseInput(riB), px0=parseInput(riPx), py0=parseInput(riPy), M0=parseInput(riM);
      if([a0,b0,px0,py0,M0].some(v=>!Number.isFinite(v))) return;
      lastExpr.a=riA.value.trim(); lastExpr.b=riB.value.trim(); lastExpr.px=riPx.value.trim(); lastExpr.py=riPy.value.trim(); lastExpr.M=riM.value.trim();
      riM.dataset.currentM = M0; // 현재 M 갱신
      applyInitial(a0,b0,px0,py0,M0);
      reinitBox.open=false;
    });
    cancelReinit.addEventListener('click', ()=>{ reinitBox.open=false; });

    // 수동 축 재설정
    refitBtn.addEventListener('click', ()=>recomputeAndDraw({fitAxes:true}));

    // 연도 표기
    document.addEventListener('DOMContentLoaded', ()=>{
      const y=document.querySelector('#year'); if(y) y.textContent=new Date().getFullYear();
    });
  })();
  </script>
</body>
</html>
