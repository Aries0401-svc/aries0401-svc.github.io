<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>선형 수요·공급 곡선 | Micro</title>
  <meta name="description" content="수요 Q = s_d·P + t_d, 공급 Q = s_s·P + t_s 를 시각화하고 균형점과 소비자·생산자 잉여, 세금 효과를 보여줍니다." />

  <!-- 공통: 폰트/스타일 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />
  <link rel="stylesheet" href="../../assets/mobile.css" media="(max-width: 768px)" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" defer></script>

  <style>
    main.grid { grid-template-columns: minmax(300px,460px) 1fr; }
    .controls { display:flex; flex-direction:column; gap:12px; }
    .eq { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; }
    .eq code { color:var(--muted); }
    .eq input, .eq select{
      width:16ch;
      border:1px solid var(--muted);
      background:var(--panel);
      color:var(--text);
      padding:.4rem .6rem;
      border-radius:.5rem;
      box-shadow: var(--shadow);
      font:inherit;
    }
    .controls button {
      border:1px solid var(--muted);
      background:var(--panel);
      color:var(--text);
      padding:.5rem .75rem;
      border-radius:.5rem;
      box-shadow: var(--shadow);
      font:inherit;
      cursor:pointer;
    }
    .controls input:focus-visible,
    .controls select:focus-visible,
    .controls button:focus-visible,
    canvas:focus-visible { outline:0; box-shadow:0 0 0 4px var(--ring); }
    .invalid{ border-color:var(--ring); }

    .chart-wrap{ position:relative; height:460px; }

    /* 커스텀 범례 (Cobb–Douglas 페이지 형식과 동일 스타일) */
    .legend { display:flex; gap:12px; flex-wrap:wrap; color:var(--muted); font-size:.92rem; }
    .badge { display:inline-flex; align-items:center; gap:.4rem; }
    .swatch { width:.75rem; height:.75rem; border-radius:50%; border:1px solid var(--muted); background:var(--panel); }

    .nums { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:.25rem .75rem; }
    .nums dt{ color:var(--muted); }
    .nums dd{ margin:0; font-weight:600; }

    .muted{ color:var(--muted); }
    [hidden]{ display:none !important; }

    /* 세금 패널 */
    #taxPanel{
      padding:12px;
      background:var(--panel);
      border:1px dashed var(--muted);
      border-radius:.5rem;
    }
  </style>
</head>
<body>
  <header class="site-header">
    <h1>선형 수요·공급 곡선</h1>
    <p class="subtitle">수요: <em>Q = s<sub>d</sub>·P + t<sub>d</sub></em>, 공급: <em>Q = s<sub>s</sub>·P + t<sub>s</sub></em></p>
  </header>

  <main class="grid">
    <!-- 컨트롤 -->
    <section class="card controls" aria-labelledby="ctl-title">
      <h2 id="ctl-title">식으로 입력 (분수/표현식 가능)</h2>

      <div class="eq" aria-label="수요곡선 식 입력">
        <strong>수요</strong>
        <code>Q =</code>
        <input id="sd" inputmode="text" value="-1" aria-label="수요 기울기 s_d (예: -1/2, -(3/4))" placeholder="-1/2">
        <code>·P +</code>
        <input id="td" inputmode="text" value="120" aria-label="수요 절편 t_d (예: 120, 3/2)" placeholder="120">
      </div>

      <div class="eq" aria-label="공급곡선 식 입력">
        <strong>공급</strong>
        <code>Q =</code>
        <input id="ss" inputmode="text" value="1" aria-label="공급 기울기 s_s (예: 1/3)" placeholder="1/3">
        <code>·P +</code>
        <input id="ts" inputmode="text" value="20" aria-label="공급 절편 t_s (예: 20, 5/4)" placeholder="20">
      </div>

      <!-- 세금부과 버튼/패널: '다시 렌더링'보다 위 -->
      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.25rem;">
        <button id="taxBtn" title="세금 설정 패널 열기/닫기">세금부과</button>
      </div>

      <!-- 세금 설정 패널 -->
      <div id="taxPanel" hidden>
        <h3 style="margin:0 0 .5rem 0;">세금 설정</h3>
        <div class="eq" aria-label="세금 금액">
          <strong>세액</strong>
          <input id="taxAmt" inputmode="text" value="0" aria-label="1단위당 세액 (예: 10, 5/2)" placeholder="예: 10">
          <span class="muted">/ 단위</span>
        </div>
        <div class="eq" aria-label="부과 대상">
          <strong>부과 대상</strong>
          <select id="taxSide" aria-label="세금을 부과할 쪽">
            <option value="none">— 선택 —</option>
            <option value="consumer">소비자(수요)</option>
            <option value="producer">생산자(공급)</option>
          </select>
          <button id="applyTaxBtn" title="세금 적용">적용</button>
          <button id="clearTaxBtn" title="세금 해제">해제</button>
        </div>
        <p class="muted" style="margin:.25rem 0 0 0;">세금은 1단위당 고정세입니다. (빨간색: 세후 곡선, 노란색: 자중손실)</p>
      </div>

      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.25rem;">
        <button id="refitBtn" title="현재 곡선과 균형점을 모두 포함하도록 축을 다시 맞춥니다.">다시 렌더링</button>
        <span class="muted" id="statusMsg" aria-live="polite"></span>
      </div>

      <dl class="nums" aria-live="polite" style="margin-top:.5rem;">
        <dt>P* (균형가격)</dt><dd id="pStar">–</dd>
        <dt>Q* (균형수량)</dt><dd id="qStar">–</dd>
        <dt>소비자잉여 (CS)</dt><dd id="csVal">–</dd>
        <dt>생산자잉여 (PS)</dt><dd id="psVal">–</dd>
        <dt>자중손실 (DWL)</dt><dd id="dwlVal">–</dd>
        <dt>소비자 조세부담</dt><dd id="ctaxVal">–</dd>
        <dt>생산자 조세부담</dt><dd id="ptaxVal">–</dd>
      </dl>

      <p class="muted">입력 예: <code>-1/2</code>, <code>(-3/4) + 0.1</code>, <code>1÷3</code>, <code>2·(3/5)</code> … (사칙/괄호 지원)</p>
    </section>

    <!-- 차트 -->
    <section class="card" aria-labelledby="chart-title">
      <h2 id="chart-title">수요·공급 그래프</h2>

      <!-- 커스텀 범례 (차트 위에 배치) -->
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <div class="legend" aria-hidden="true">
          <span class="badge"><span class="swatch" style="background:var(--primary)"></span>수요곡선</span>
          <span class="badge"><span class="swatch" style="background:var(--text)"></span>공급곡선</span>
          <span class="badge"><span class="swatch" style="background:var(--primary)"></span>소비자잉여</span>
          <span class="badge"><span class="swatch" style="background:var(--text)"></span>생산자잉여</span>
          <span class="badge"><span class="swatch" style="background:#facc15"></span>자중손실</span>
          <span class="badge"><span class="swatch" style="background:#e11d48"></span>세후곡선</span>
        </div>
      </div>

      <div class="chart-wrap">
        <canvas id="sdcChart" data-responsive tabindex="0" aria-label="수요·공급 곡선과 균형점, 잉여, 세금 후 변화"></canvas>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
    <small>© <span id="year"></span> aries0401-svc</small>
  </footer>

  <!-- 공통 스크립트 -->
  <script src="../../assets/mobile-init.js" defer></script>
  <script src="../../assets/site.js" defer></script>

  <!-- 페이지 전용 스크립트 -->
  <script>
    // ====== 유틸/상수 ======
    const $ = (s)=>document.querySelector(s);

    // 입력 엘리먼트
    const sd=$('#sd'), td=$('#td'), ss=$('#ss'), ts=$('#ts');
    const refitBtn=$('#refitBtn'), statusMsg=$('#statusMsg');
    const pStarEl=$('#pStar'), qStarEl=$('#qStar'), csValEl=$('#csVal'), psValEl=$('#psVal'), dwlValEl=$('#dwlVal');
    const ctaxValEl=$('#ctaxVal'), ptaxValEl=$('#ptaxVal');
    const taxBtn=$('#taxBtn'), taxPanel=$('#taxPanel'), taxAmt=$('#taxAmt'), taxSide=$('#taxSide');
    const applyTaxBtn=$('#applyTaxBtn'), clearTaxBtn=$('#clearTaxBtn');

    // CSS 색
    function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    function withAlpha(color, alpha=0.22){
      const aByte = Math.round(alpha*255).toString(16).padStart(2,'0');
      if(/^#([0-9a-f]{6})$/i.test(color)) return color + aByte;
      if(/^#([0-9a-f]{3})$/i.test(color)){
        const r=color[1], g=color[2], b=color[3];
        return '#'+r+r+g+g+b+b+aByte;
      }
      return color;
    }
    const TAX_RED = '#e11d48';
    const DWL_YELLOW = '#facc15';

    // 안전한 사칙연산 파서
    function evalExpr(raw){
      if(typeof raw!=='string') return NaN;
      let s = raw.trim();
      if(!s) return NaN;
      s = s.replace(/\s+/g,'').replace(/[−–—]/g,'-').replace(/[×·]/g,'*').replace(/[÷⁄]/g,'/');
      const tokens=[]; let i=0, prev=null;
      const isDigit=c=>/[0-9.]/.test(c);
      while(i<s.length){
        const c=s[i];
        if(isDigit(c) || (c==='-' && (prev===null || /[+\-*/(]/.test(prev)) && isDigit(s[i+1]))){
          let j=i+1; while(j<s.length && /[0-9.]/.test(s[j])) j++;
          tokens.push(s.slice(i,j)); prev='n'; i=j; continue;
        }
        if('+-*/()'.includes(c)){ tokens.push(c); prev=c; i++; continue; }
        return NaN;
      }
      const out=[], op=[], prec={'+':1,'-':1,'*':2,'/':2};
      for(const t of tokens){
        if(t in prec){
          while(op.length && (op[op.length-1] in prec) && prec[op[op.length-1]]>=prec[t]) out.push(op.pop());
          op.push(t);
        }else if(t==='('){ op.push(t); }
        else if(t===')'){
          while(op.length && op[op.length-1]!=='(') out.push(op.pop());
          if(!op.length) return NaN; op.pop();
        }else out.push(t);
      }
      while(op.length){ const k=op.pop(); if(k==='('||k===')') return NaN; out.push(k); }
      const st=[];
      for(const t of out){
        if(t in prec){
          const b=+st.pop(), a=+st.pop(); if(!Number.isFinite(a)||!Number.isFinite(b)) return NaN;
          st.push(t==='+'?a+b:t==='-'?a-b:t==='*'?a*b:(b===0?NaN:a/b));
        }else{ const v=+t; if(!Number.isFinite(v)) return NaN; st.push(v); }
      }
      if(st.length!==1) return NaN;
      const res=+st[0]; return Number.isFinite(res)?res:NaN;
    }
    function parseInput(el){
      const v = evalExpr(el.value);
      el.classList.toggle('invalid', !Number.isFinite(v));
      return v;
    }

    // 축 상태 (단일 선언)
    let BASE_QMAX=1, BASE_PMAX=1;

    // 세금 상태 (단일 선언)
    let TAX_ON=false, TAX_T=0, TAX_SIDE='none';

    // 포맷 유틸
    const fmt = (v, d=2)=> (Number.isFinite(v)?(+v).toFixed(d):'–');
    const fmtPct = (v)=> (Number.isFinite(v)? (v*100).toFixed(1)+'%' : '–');

    function params(){ return { sd:parseInput(sd), td:parseInput(td), ss:parseInput(ss), ts:parseInput(ts) }; }

    function fitAxes(sd,td,ss,ts){
      const Pchoke = (sd!==0)? (-td/sd) : NaN;
      const Pmin   = (ss!==0)? (-ts/ss) : NaN;
      const denom  = (ss - sd);
      const pStar  = (denom!==0)? (td - ts)/denom : 0;
      const qStar  = (denom!==0)? (sd*pStar + td) : 0;

      const PmaxCandidate = Math.max(0,
        Number.isFinite(Pchoke)? Pchoke : 0,
        Number.isFinite(Pmin)?   Pmin   : 0,
        Number.isFinite(pStar)?  pStar  : 0
      );
      BASE_PMAX = (PmaxCandidate>0? PmaxCandidate*1.25 : 1);

      const Qd0 = td, Qs0 = ts;
      const QdPmax = sd*BASE_PMAX + td, QsPmax = ss*BASE_PMAX + ts;

      const QmaxCandidate = Math.max(0,
        Number.isFinite(Qd0)?Qd0:0, Number.isFinite(Qs0)?Qs0:0,
        Number.isFinite(QdPmax)?QdPmax:0, Number.isFinite(QsPmax)?QsPmax:0,
        Number.isFinite(qStar)?qStar:0
      );
      BASE_QMAX = (QmaxCandidate>0? QmaxCandidate*1.25 : 1);
    }

    // 차트
    let sdcChart;
    function createChart(){
      const ctx = document.getElementById('sdcChart').getContext('2d');
      sdcChart = new Chart(ctx,{
        type:'line',
        data:{ datasets:[
          { label:'수요', data:[], borderColor:cssVar('--primary'), borderWidth:2, fill:false, tension:0, pointRadius:0, parsing:false },
          { label:'공급', data:[], borderColor:cssVar('--text'), borderWidth:2, fill:false, tension:0, pointRadius:0, parsing:false },

          { label:'CS-Base', data:[], borderColor:'transparent', backgroundColor:'transparent', pointRadius:0, borderWidth:0, parsing:false, fill:false },
          { label:'소비자잉여', data:[], borderColor:'transparent', backgroundColor:withAlpha(cssVar('--primary'),0.22),
            pointRadius:0, tension:0, parsing:false, fill:{ target:2 } },

          { label:'PS-Base', data:[], borderColor:'transparent', backgroundColor:'transparent', pointRadius:0, borderWidth:0, parsing:false, fill:false },
          { label:'생산자잉여', data:[], borderColor:'transparent', backgroundColor:withAlpha(cssVar('--text'),0.18),
            pointRadius:0, tension:0, parsing:false, fill:{ target:4 } },

          // ✅ 동그란 점(균형점)
          { label:'균형점', data:[], parsing:false, showLine:false, pointRadius:5, pointHoverRadius:6,
            pointBackgroundColor:cssVar('--primary'), pointBorderColor:cssVar('--text'), pointBorderWidth:0, type:'scatter' },

          // 점선 투영
          { label:'Q* 투영', data:[], borderColor:cssVar('--primary'), borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, parsing:false },
          { label:'P* 투영', data:[], borderColor:cssVar('--primary'), borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, parsing:false },

          // 세금 후
          { label:'세후 곡선', data:[], borderColor:TAX_RED, borderWidth:2, fill:false, tension:0, pointRadius:0, parsing:false },

          { label:'세후 CS-Base', data:[], borderColor:'transparent', backgroundColor:'transparent', pointRadius:0, borderWidth:0, parsing:false, fill:false },
          { label:'세후 소비자잉여', data:[], borderColor:'transparent', backgroundColor:withAlpha(cssVar('--primary'),0.22),
            pointRadius:0, tension:0, parsing:false, fill:{ target:10 } },

          { label:'세후 PS-Base', data:[], borderColor:'transparent', backgroundColor:'transparent', pointRadius:0, borderWidth:0, parsing:false, fill:false },
          { label:'세후 생산자잉여', data:[], borderColor:'transparent', backgroundColor:withAlpha(cssVar('--text'),0.18),
            pointRadius:0, tension:0, parsing:false, fill:{ target:12 } },

          // DWL (노란색 면적)
          { label:'DWL-Top', data:[], borderColor:'transparent', backgroundColor:'transparent', pointRadius:0, borderWidth:0, parsing:false, fill:false },
          { label:'자중손실', data:[], borderColor:'transparent', backgroundColor:withAlpha(DWL_YELLOW,0.5),
            pointRadius:0, tension:0, parsing:false, fill:{ target:14 } },

          // 세후 투영/쐐기
          { label:'Q_t 투영', data:[], borderColor:TAX_RED, borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, parsing:false },
          { label:'P_c(세후) 투영', data:[], borderColor:TAX_RED, borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, parsing:false },
          { label:'P_p(세후) 투영', data:[], borderColor:TAX_RED, borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, parsing:false },
          { label:'세금쐐기', data:[], borderColor:TAX_RED, borderWidth:2, fill:false, tension:0, pointRadius:0, parsing:false }
        ]},
        options:{
          responsive:true,
          maintainAspectRatio:false,
          animation:false,
          elements:{ point:{ radius:0, hoverRadius:0 }, line:{ tension:0 } },
          scales:{
            x:{ type:'linear', title:{display:true,text:'Q (수량)'}, grid:{ color:cssVar('--muted') }, min:0, max:BASE_QMAX },
            y:{ type:'linear', title:{display:true,text:'P (가격)'}, grid:{ color:cssVar('--muted') }, min:0, max:BASE_PMAX }
          },
          plugins:{
            legend:{ display:false },  // ❗ 커스텀 범례만 사용 (Chart.js 범례 숨김)
            tooltip:{ mode:'nearest', intersect:false }
          }
        }
      });
    }

    // 샘플링 유틸
    function sampleLineQP(qOfP, Pmax, N=240){
      const arr=[]; for(let i=0;i<=N;i++){ const t=i/N, P=t*Pmax; const Q=qOfP(P); if(Number.isFinite(Q)) arr.push({x:Q, y:P}); }
      return arr;
    }
    function segment_PofQ(PofQ, QmaxSeg, N=100){
      const arr=[]; for(let i=0;i<=N;i++){ const t=i/N, Q=t*QmaxSeg; const P=PofQ(Q); if(Number.isFinite(P)) arr.push({x:Q, y:P}); }
      return arr;
    }
    function segment_PofQ_range(PofQ, Qstart, Qend, N=80){
      const arr=[]; for(let i=0;i<=N;i++){ const t=i/N, Q=Qstart + t*(Qend-Qstart); const P=PofQ(Q); if(Number.isFinite(P)) arr.push({x:Q, y:P}); }
      return arr;
    }

    function recomputeAndDraw({fit=false}={}){
      const {sd:SD, td:TD, ss:SS, ts:TS} = params();

      // 검증/안내
      const problems=[];
      if(!Number.isFinite(SD)||!Number.isFinite(TD)||!Number.isFinite(SS)||!Number.isFinite(TS)) problems.push('표현식을 올바르게 입력해주세요.');
      if(Number.isFinite(SD) && !(SD<0)) problems.push('수요 기울기 s_d는 보통 음수입니다.');
      if(Number.isFinite(SS) && !(SS>0)) problems.push('공급 기울기 s_s는 보통 양수입니다.');
      const denom = (SS - SD);
      if(Number.isFinite(denom) && denom===0) problems.push('s_s - s_d = 0이면 균형이 정의되지 않습니다.');
      statusMsg.textContent = problems.join(' ');

      // (세전) 균형
      const pStar0 = (denom!==0)? (TD - TS)/denom : NaN;
      const qStar0 = (denom!==0)? (SD*pStar0 + TD) : NaN;

      // 축 재설정
      if(fit && [SD,TD,SS,TS].every(Number.isFinite)){ fitAxes(SD,TD,SS,TS); }
      sdcChart.options.scales.x.max = BASE_QMAX;
      sdcChart.options.scales.y.max = BASE_PMAX;

      // 원곡선
      const demandAll = sampleLineQP(P=>SD*P + TD, BASE_PMAX);
      const supplyAll = sampleLineQP(P=>SS*P + TS, BASE_PMAX);

      // P(Q)
      const Pd = (Q)=> (SD!==0)? ((Q - TD)/SD) : NaN;
      const Ps = (Q)=> (SS!==0)? ((Q - TS)/SS) : NaN;

      // (세전) 잉여 & 동그란 점/투영
      let csBase=[], csSeg=[], psBase=[], psSeg=[], eqPt=[], vProj=[], hProj=[];
      let CS0=NaN, PS0=NaN;
      const valid0 = [pStar0,qStar0,SD,SS].every(Number.isFinite) && (pStar0>=0) && (qStar0>=0);
      if(valid0){
        const Pchoke = (SD!==0)? (-TD/SD) : NaN;
        const Pmin   = (SS!==0)? (-TS/SS) : NaN;
        CS0 = 0.5 * Math.max(0, (Pchoke - pStar0)) * qStar0;
        PS0 = 0.5 * Math.max(0, (pStar0 - Pmin)) * qStar0;

        csBase = [{x:0, y:pStar0}, {x:qStar0, y:pStar0}];
        psBase = csBase.slice();
        csSeg  = segment_PofQ(Pd, qStar0);
        psSeg  = segment_PofQ(Ps, qStar0);

        eqPt   = [{x:qStar0, y:pStar0}];                      // 동그란 점(세전)
        vProj  = [{x:qStar0, y:0}, {x:qStar0, y:pStar0}];
        hProj  = [{x:0, y:pStar0}, {x:qStar0, y:pStar0}];
      }

      // === 세금 ===
      let taxedLine=[], tcsBase=[], tcsSeg=[], tpsBase=[], tpsSeg=[];
      let dwlTop=[], dwlFill=[], vProjTax=[], hPc=[], hPp=[], wedge=[];
      let pC=NaN, pP=NaN, qT=NaN, CS=CS0, PS=PS0, DWL=NaN;
      let CTAX_AMT=NaN, PTAX_AMT=NaN, CTAX_SH=NaN, PTAX_SH=NaN;

      const T = TAX_ON ? TAX_T : 0;
      const SIDE = TAX_ON ? TAX_SIDE : 'none';

      if(T>0 && (SIDE==='consumer'||SIDE==='producer') && valid0){
        if(SIDE==='consumer'){
          const TDp = TD + SD*T;               // 수요를 T만큼 아래(생산자 가격 기준)
          pP = (SS - SD)!==0 ? (TDp - TS)/(SS - SD) : NaN;
          qT = Number.isFinite(pP) ? (SS*pP + TS) : NaN;
          pC = Number.isFinite(pP) ? (pP + T) : NaN;
          taxedLine = sampleLineQP(P=>SD*(P + T) + TD, BASE_PMAX);
        }else{
          const TSp = TS - SS*T;               // 공급을 T만큼 위(소비자 가격 기준)
          pC = (SS - SD)!==0 ? (TD - TSp)/(SS - SD) : NaN;
          qT = Number.isFinite(pC) ? (SD*pC + TD) : NaN;
          pP = Number.isFinite(pC) ? (pC - T) : NaN;
          taxedLine = sampleLineQP(P=>SS*(P - T) + TS, BASE_PMAX);
        }

        const Pchoke = (SD!==0)? (-TD/SD) : NaN;
        const Pmin   = (SS!==0)? (-TS/SS) : NaN;
        if([pC,pP,qT,Pchoke,Pmin,pStar0].every(Number.isFinite) && qT>=0){
          CS  = 0.5 * Math.max(0, (Pchoke - pC)) * qT;
          PS  = 0.5 * Math.max(0, (pP - Pmin)) * qT;
          const TR = T * qT;

          // 조세부담 (금액/비중)
          CTAX_AMT = Math.max(0, (pC - pStar0)) * qT;
          PTAX_AMT = Math.max(0, (pStar0 - pP)) * qT;
          if(TR>0){ CTAX_SH = CTAX_AMT/TR; PTAX_SH = PTAX_AMT/TR; }

          // 자중손실
          DWL = Math.max(0, (CS0 + PS0) - (CS + PS) - TR);

          // 세후 잉여
          tcsBase = [{x:0, y:pC}, {x:qT, y:pC}];
          tcsSeg  = segment_PofQ(Pd, qT);
          tpsBase = [{x:0, y:pP}, {x:qT, y:pP}];
          tpsSeg  = segment_PofQ(Ps, qT);

          // DWL (Q: qT → qStar0)
          if(qT<=qStar0){
            dwlTop  = segment_PofQ_range(Pd, qT, qStar0);
            dwlFill = segment_PofQ_range(Ps, qT, qStar0);
          }

          // 동그란 점(세후, 소비자가격) & 투영
          eqPt     = [{x:qT, y:pC}];
          vProjTax = [{x:qT, y:0}, {x:qT, y:pC}];
          hPc      = [{x:0, y:pC}, {x:qT, y:pC}];
          hPp      = [{x:0, y:pP}, {x:qT, y:pP}];
          wedge    = [{x:qT, y:pP}, {x:qT, y:pC}];
        }
      }

      // 차트 반영
      const ds = sdcChart.data.datasets;

      // 원곡선
      ds[0].data = demandAll;
      ds[1].data = supplyAll;

      // 잉여(세전/세후)
      if(T>0 && Number.isFinite(CS) && Number.isFinite(PS) && Number.isFinite(pC) && Number.isFinite(pP) && Number.isFinite(qT)){
        ds[2].data = tcsBase; ds[3].data = tcsSeg;
        ds[4].data = tpsBase; ds[5].data = tpsSeg;
      }else{
        ds[2].data = csBase;  ds[3].data = csSeg;
        ds[4].data = psBase;  ds[5].data = psSeg;
      }

      // ✅ 동그란 점/투영 (세전/세후 전환)
      if(T>0 && Number.isFinite(qT) && Number.isFinite(pC)){
        ds[6].data = eqPt;
        ds[7].data = vProjTax; ds[7].borderColor = TAX_RED;
        ds[8].data = hPc;      ds[8].borderColor = TAX_RED;
      }else{
        ds[6].data = eqPt;
        ds[7].data = vProj;    ds[7].borderColor = cssVar('--primary');
        ds[8].data = hProj;    ds[8].borderColor = cssVar('--primary');
      }

      // 세금 시각 요소
      ds[9].data  = (T>0)? taxedLine : [];
      ds[10].data = tcsBase; ds[11].data = tcsSeg;
      ds[12].data = tpsBase; ds[13].data = tpsSeg;

      ds[14].data = dwlTop;
      ds[15].data = dwlFill;

      ds[16].data = (T>0 && Number.isFinite(qT)) ? [{x:qT, y:0}, {x:qT, y:Math.max(pC||0,pP||0)}] : [];
      ds[17].data = (T>0 && Number.isFinite(pC) && Number.isFinite(qT)) ? hPc : [];
      ds[18].data = (T>0 && Number.isFinite(pP) && Number.isFinite(qT)) ? hPp : [];
      ds[19].data = (T>0 && Number.isFinite(pC) && Number.isFinite(pP) && Number.isFinite(qT)) ? wedge : [];

      sdcChart.update('none');

      // 숫자 반영
      const showP  = (T>0 && Number.isFinite(pC)) ? pC : pStar0;
      const showQ  = (T>0 && Number.isFinite(qT)) ? qT : qStar0;
      const showCS = (T>0 && Number.isFinite(CS)) ? CS : CS0;
      const showPS = (T>0 && Number.isFinite(PS)) ? PS : PS0;
      const showDWL= (T>0 && Number.isFinite(DWL)) ? DWL : NaN;

      pStarEl.textContent = fmt(showP,2);
      qStarEl.textContent = fmt(showQ,2);
      csValEl.textContent = fmt(showCS,2);
      psValEl.textContent = fmt(showPS,2);
      dwlValEl.textContent= fmt(showDWL,2);

      const TR = (T>0 && Number.isFinite(qT)) ? T*qT : NaN;
      if(T>0 && Number.isFinite(TR) && TR>0 && Number.isFinite(CTAX_AMT) && Number.isFinite(PTAX_AMT)){
        ctaxValEl.textContent = `${fmt(CTAX_AMT,2)} (${fmtPct(CTAX_SH)})`;
        ptaxValEl.textContent = `${fmt(PTAX_AMT,2)} (${fmtPct(PTAX_SH)})`;
      }else{
        ctaxValEl.textContent = '–';
        ptaxValEl.textContent = '–';
      }
    }

    // 이벤트 바인딩
    [sd,td,ss,ts].forEach(inp=>{
      inp.addEventListener('input', ()=>recomputeAndDraw());
      inp.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); recomputeAndDraw(); } });
    });
    refitBtn.addEventListener('click', ()=>recomputeAndDraw({fit:true}));

    function applyTaxFromUI(){
      const t = parseInput(taxAmt);
      const side = taxSide.value;
      TAX_T = Math.max(0, Number.isFinite(t)? t : 0);
      TAX_SIDE = (side==='consumer'||side==='producer') ? side : 'none';
      TAX_ON = TAX_T>0 && TAX_SIDE!=='none';
      recomputeAndDraw({fit:true});
      statusMsg.textContent='';
    }
    taxBtn.addEventListener('click', ()=>{ taxPanel.hidden = !taxPanel.hidden; });
    applyTaxBtn.addEventListener('click', applyTaxFromUI);
    clearTaxBtn.addEventListener('click', ()=>{
      TAX_ON=false; TAX_T=0; TAX_SIDE='none';
      taxAmt.value='0'; taxSide.value='none';
      recomputeAndDraw({fit:true});
      statusMsg.textContent='';
    });

    // 자동 적용 제거: 값 변경 시 안내만 표시 (적용 버튼을 눌러야 반영)
    taxAmt.addEventListener('input', ()=>{
      statusMsg.textContent='세금 변경사항은 "적용"을 눌러야 반영됩니다.';
    });
    taxSide.addEventListener('change', ()=>{
      statusMsg.textContent='세금 변경사항은 "적용"을 눌러야 반영됩니다.';
    });

    // 초기화
    document.addEventListener('DOMContentLoaded', ()=>{
      const y = document.querySelector('#year'); if(y) y.textContent = new Date().getFullYear();
      const p = params();
      if([p.sd,p.td,p.ss,p.ts].every(Number.isFinite)) fitAxes(p.sd,p.td,p.ss,p.ts);
      createChart();
      recomputeAndDraw({fit:true});
    });
  </script>
</body>
</html>
