<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>선형 수요·공급 곡선 | Micro</title>
  <meta name="description" content="수요 Q = s_d·P + t_d, 공급 Q = s_s·P + t_s 를 시각화하고 균형점과 소비자·생산자 잉여를 한 그래프에서 보여줍니다. 분수/표현식 입력 지원." />

  <!-- 공통: 폰트/스타일 (상대경로 고정) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />

  <!-- 차트(CDN, 버전 고정) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" defer></script>

  <style>
    main.grid { grid-template-columns: minmax(300px,460px) 1fr; }
    .controls { display:flex; flex-direction:column; gap:12px; }
    .eq { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; }
    .eq code { color:var(--muted); }
    .eq input{
      width:16ch;
      border:1px solid var(--muted);
      background:var(--panel);
      color:var(--text);
      padding:.4rem .6rem;
      border-radius:.5rem;
      box-shadow: var(--shadow);
      font:inherit;
    }
    .controls button {
      border:1px solid var(--muted);
      background:var(--panel);
      color:var(--text);
      padding:.5rem .75rem;
      border-radius:.5rem;
      box-shadow: var(--shadow);
      font:inherit;
      cursor:pointer;
    }
    .controls input:focus-visible,
    .controls button:focus-visible,
    canvas:focus-visible { outline:0; box-shadow:0 0 0 4px var(--ring); }
    .invalid{ border-color:var(--ring); }

    .chart-wrap{ position:relative; height:460px; }
    .legend { display:flex; gap:12px; flex-wrap:wrap; color:var(--muted); font-size:.92rem; }
    .badge { display:inline-flex; align-items:center; gap:.4rem; }
    .swatch { width:.75rem; height:.75rem; border-radius:50%; border:1px solid var(--muted); background:var(--panel); }

    .nums { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:.25rem .75rem; }
    .nums dt{ color:var(--muted); }
    .nums dd{ margin:0; font-weight:600; }

    .muted{ color:var(--muted); }
    [hidden]{ display:none !important; }
  </style>
</head>
<body>
  <header class="site-header">
    <h1>선형 수요·공급 곡선</h1>
    <p class="subtitle">수요: <em>Q = s<sub>d</sub>·P + t<sub>d</sub></em>, 공급: <em>Q = s<sub>s</sub>·P + t<sub>s</sub></em></p>
  </header>

  <main class="grid">
    <!-- 컨트롤 -->
    <section class="card controls" aria-labelledby="ctl-title">
      <h2 id="ctl-title">식으로 입력 (분수/표현식 가능)</h2>

      <div class="eq" aria-label="수요곡선 식 입력">
        <strong>수요</strong>
        <code>Q =</code>
        <input id="sd" inputmode="text" value="-1" aria-label="수요 기울기 s_d (예: -1/2, -(3/4))" placeholder="-1/2">
        <code>·P +</code>
        <input id="td" inputmode="text" value="120" aria-label="수요 절편 t_d (예: 120, 3/2)" placeholder="120">
      </div>

      <div class="eq" aria-label="공급곡선 식 입력">
        <strong>공급</strong>
        <code>Q =</code>
        <input id="ss" inputmode="text" value="1" aria-label="공급 기울기 s_s (예: 1/3)" placeholder="1/3">
        <code>·P +</code>
        <input id="ts" inputmode="text" value="20" aria-label="공급 절편 t_s (예: 20, 5/4)" placeholder="20">
      </div>

      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.25rem;">
        <button id="refitBtn" title="현재 곡선과 균형점을 모두 포함하도록 축을 다시 맞춥니다.">다시 렌더링</button>
        <span class="muted" id="statusMsg" aria-live="polite"></span>
      </div>

      <dl class="nums" aria-live="polite" style="margin-top:.5rem;">
        <dt>P* (균형가격)</dt><dd id="pStar">–</dd>
        <dt>Q* (균형수량)</dt><dd id="qStar">–</dd>
        <dt>소비자잉여 (CS)</dt><dd id="csVal">–</dd>
        <dt>생산자잉여 (PS)</dt><dd id="psVal">–</dd>
      </dl>
      <p class="muted">입력 예: <code>-1/2</code>, <code>(-3/4) + 0.1</code>, <code>1÷3</code>, <code>2·(3/5)</code> … (사칙/괄호 지원)</p>
    </section>

    <!-- 차트 -->
    <section class="card" aria-labelledby="chart-title">
      <h2 id="chart-title">수요·공급, 균형점·잉여(한 그래프)</h2>

      <div class="legend" aria-hidden="true">
        <span class="badge"><span class="swatch" style="background:var(--primary)"></span>수요</span>
        <span class="badge"><span class="swatch" style="background:var(--text)"></span>공급</span>
        <span class="badge"><span class="swatch" style="background:var(--primary)"></span>소비자잉여</span>
        <span class="badge"><span class="swatch" style="background:var(--text)"></span>생산자잉여</span>
      </div>

      <div class="chart-wrap">
        <canvas id="sdcChart" tabindex="0" aria-label="수요·공급 곡선과 균형점, 소비자/생산자 잉여"></canvas>
      </div>
      <p class="muted" style="margin-top:8px;">축: 가로(Q, 수량), 세로(P, 가격). 식을 바꾸면 곡선·균형점·잉여가 즉시 갱신됩니다.</p>
    </section>
  </main>

  <footer class="site-footer">
    <a class="card" href="../" style="display:inline-block;padding:12px 18px;">← 이전으로</a>
    <a class="card" href="../../" style="display:inline-block;padding:12px 18px;">← 처음으로</a>
    <small>© <span id="year"></span> aries0401-svc</small>
  </footer>

  <!-- 공통 스크립트 -->
  <script src="../../assets/site.js" defer></script>

  <!-- 페이지 전용 스크립트 -->
  <script>
    // ====== 선형 수요·공급 — 분수/표현식 입력 지원, 균형/잉여 시각화 ======
    const $ = (s)=>document.querySelector(s);

    // 입력
    const sd=$('#sd'), td=$('#td'), ss=$('#ss'), ts=$('#ts');
    const refitBtn=$('#refitBtn'), statusMsg=$('#statusMsg');
    const pStarEl=$('#pStar'), qStarEl=$('#qStar'), csValEl=$('#csVal'), psValEl=$('#psVal');

    // CSS 변수 → 실제 색상
    function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    let C_TEXT, C_PRIMARY, C_MUTED;
    function loadColors(){ C_TEXT=cssVar('--text'); C_PRIMARY=cssVar('--primary'); C_MUTED=cssVar('--muted'); }
    function withAlpha(color, alpha=0.22){
      const aByte = Math.round(alpha*255).toString(16).padStart(2,'0');
      if(/^#([0-9a-f]{6})$/i.test(color)) return color + aByte;
      if(/^#([0-9a-f]{3})$/i.test(color)){ const r=color[1],g=color[2],b=color[3]; return '#'+r+r+g+g+b+b+aByte; }
      return color; // rgb/hsl은 그대로
    }

    // -------- 안전한 사칙연산 파서 (셔닝야드) --------
    // 지원: + - ×(x/·) * ÷ /, (), 소수, 분수, 공백/유니코드 기호
    function evalExpr(raw){
      if(typeof raw!=='string') return NaN;
      let s = raw.trim();
      if(!s) return NaN;
      s = s.replace(/\s+/g,'')
           .replace(/[−–—]/g,'-')        // 유니코드 마이너스
           .replace(/[×·]/g,'*')         // 곱
           .replace(/[÷]/g,'/')          // 나눗셈 기호
           .replace(/[⁄]/g,'/');         // fraction slash
      // 토크나이저
      const tokens = [];
      let i=0, prev=null;
      const isDigit = c => /[0-9.]/.test(c);
      while(i<s.length){
        const c=s[i];
        if(isDigit(c) || (c==='-' && (prev===null || /[+\-*/(]/.test(prev)) && isDigit(s[i+1]))){
          // 숫자(선행 단항 - 포함)
          let j=i+1;
          while(j<s.length && /[0-9.]/.test(s[j])) j++;
          tokens.push(s.slice(i,j));
          prev='n'; i=j; continue;
        }
        if('+-*/()'.includes(c)){
          tokens.push(c); prev=c; i++; continue;
        }
        // 에러 토큰
        return NaN;
      }

      // 셔닝야드로 RPN 변환
      const out=[], op=[];
      const prec = {'+':1,'-':1,'*':2,'/':2};
      for(const t of tokens){
        if(t==='+'||t==='-'||t==='*'||t==='/'){
          while(op.length){
            const k=op[op.length-1];
            if((k==='+'||k==='-'||k==='*'||k==='/') && prec[k] >= prec[t]) out.push(op.pop());
            else break;
          }
          op.push(t);
        }else if(t==='('){ op.push(t); }
        else if(t===')'){
          while(op.length && op[op.length-1]!=='(') out.push(op.pop());
          if(op.length===0) return NaN; // 괄호 불일치
          op.pop(); // '(' 제거
        }else{ // 숫자
          out.push(t);
        }
      }
      while(op.length){
        const k=op.pop();
        if(k==='('||k===')') return NaN;
        out.push(k);
      }

      // RPN 평가
      const st=[];
      for(const t of out){
        if(t==='+'||t==='-'||t==='*'||t==='/'){
          const b=+st.pop(), a=+st.pop();
          if(!Number.isFinite(a) || !Number.isFinite(b)) return NaN;
          let v;
          if(t==='+') v=a+b;
          else if(t==='-') v=a-b;
          else if(t==='*') v=a*b;
          else { if(b===0) return NaN; v=a/b; }
          st.push(v);
        }else{
          const v=+t;
          if(!Number.isFinite(v)) return NaN;
          st.push(v);
        }
      }
      if(st.length!==1) return NaN;
      const res=+st[0];
      return Number.isFinite(res) ? res : NaN;
    }

    function parseInput(el){
      const v = evalExpr(el.value);
      el.classList.toggle('invalid', !Number.isFinite(v));
      return v;
    }

    // 상태: 축 고정
    let BASE_QMAX=1, BASE_PMAX=1;

    const fmt = (v, d=2)=> (Number.isFinite(v)?(+v).toFixed(d):'–');

    function params(){
      return { sd:parseInput(sd), td:parseInput(td), ss:parseInput(ss), ts:parseInput(ts) };
    }

    // 축 후보 계산
    function fitAxes(sd,td,ss,ts){
      const Pchoke = (sd!==0)? (-td/sd) : NaN;
      const Pmin   = (ss!==0)? (-ts/ss) : NaN;

      const denom  = (ss - sd);
      const pStar  = (denom!==0)? (td - ts)/denom : 0;
      const qStar  = (denom!==0)? (sd*pStar + td) : 0;

      const PmaxCandidate = Math.max(0,
        Number.isFinite(Pchoke)? Pchoke : 0,
        Number.isFinite(Pmin)?   Pmin   : 0,
        Number.isFinite(pStar)?  pStar  : 0
      );
      BASE_PMAX = (PmaxCandidate>0? PmaxCandidate*1.25 : 1);

      const Qd0 = td, Qs0 = ts;
      const QdPmax = sd*BASE_PMAX + td, QsPmax = ss*BASE_PMAX + ts;

      const QmaxCandidate = Math.max(0,
        Number.isFinite(Qd0)?Qd0:0, Number.isFinite(Qs0)?Qs0:0,
        Number.isFinite(QdPmax)?QdPmax:0, Number.isFinite(QsPmax)?QsPmax:0,
        Number.isFinite(qStar)?qStar:0
      );
      BASE_QMAX = (QmaxCandidate>0? QmaxCandidate*1.25 : 1);
    }

    // 차트
    let sdcChart;
    function createChart(){
      const ctx = document.getElementById('sdcChart').getContext('2d');
      sdcChart = new Chart(ctx,{
        type:'line',
        data:{ datasets:[
          { label:'수요', data:[], borderColor:C_PRIMARY, borderWidth:2, fill:false, tension:0, pointRadius:0, parsing:false },
          { label:'공급', data:[], borderColor:C_TEXT, borderWidth:2, fill:false, tension:0, pointRadius:0, parsing:false },

          { label:'CS-Base', data:[], borderColor:'transparent', backgroundColor:'transparent', pointRadius:0, borderWidth:0, parsing:false, fill:false },
          { label:'소비자잉여', data:[], borderColor:'transparent', backgroundColor:withAlpha(C_PRIMARY,0.22),
            pointRadius:0, tension:0, parsing:false, fill:{ target:2 } },

          { label:'PS-Base', data:[], borderColor:'transparent', backgroundColor:'transparent', pointRadius:0, borderWidth:0, parsing:false, fill:false },
          { label:'생산자잉여', data:[], borderColor:'transparent', backgroundColor:withAlpha(C_TEXT,0.18),
            pointRadius:0, tension:0, parsing:false, fill:{ target:4 } },

          { label:'균형점', data:[], parsing:false, showLine:false, pointRadius:4, pointHoverRadius:5,
            pointBackgroundColor:C_PRIMARY, pointBorderColor:C_TEXT, pointBorderWidth:0, type:'scatter' },

          { label:'Q* 투영', data:[], borderColor:C_PRIMARY, borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, parsing:false },
          { label:'P* 투영', data:[], borderColor:C_PRIMARY, borderDash:[6,4], borderWidth:1.5, fill:false, tension:0, pointRadius:0, parsing:false },
        ]},
        options:{
          responsive:true,
          maintainAspectRatio:false,
          animation:false,
          elements:{ point:{ radius:0, hoverRadius:0 }, line:{ tension:0 } },
          scales:{
            x:{ type:'linear', title:{display:true,text:'Q (수량)'}, grid:{ color:C_MUTED }, min:0, max:BASE_QMAX },
            y:{ type:'linear', title:{display:true,text:'P (가격)'}, grid:{ color:C_MUTED }, min:0, max:BASE_PMAX }
          },
          plugins:{
            legend:{ display:true, labels:{ filter:(i)=> i.text!=='CS-Base' && i.text!=='PS-Base' } },
            tooltip:{ mode:'nearest', intersect:false }
          }
        }
      });
    }

    // 선 샘플링: P∈[0,Pmax] → (Q,P)
    function sampleLineQP(qOfP, Pmax, N=240){
      const arr=[];
      for(let i=0;i<=N;i++){
        const t=i/N, P=t*Pmax;
        const Q=qOfP(P);
        if(Number.isFinite(Q)) arr.push({x:Q, y:P});
      }
      return arr;
    }

    // 잉여 세그먼트: Q∈[0,Q*]에서 P(Q) (음수 P도 생성 → 차트 뷰포트가 클리핑)
    function segment_PofQ(PofQ, QmaxSeg, N=100){
      const arr=[];
      for(let i=0;i<=N;i++){
        const t=i/N, Q=t*QmaxSeg;
        const P=PofQ(Q);
        if(Number.isFinite(P)) arr.push({x:Q, y:P});
      }
      return arr;
    }

    function recomputeAndDraw({fit=false}={}){
      const {sd:SD, td:TD, ss:SS, ts:TS} = params();

      // 검증/안내
      const problems=[];
      if(!Number.isFinite(SD)||!Number.isFinite(TD)||!Number.isFinite(SS)||!Number.isFinite(TS)){
        problems.push('표현식을 올바르게 입력해주세요.');
      }
      if(Number.isFinite(SD) && !(SD<0)) problems.push('수요 기울기 s_d는 보통 음수입니다.');
      if(Number.isFinite(SS) && !(SS>0)) problems.push('공급 기울기 s_s는 보통 양수입니다.');
      const denom = (SS - SD);
      if(Number.isFinite(denom) && denom===0) problems.push('s_s - s_d = 0이면 균형이 정의되지 않습니다.');
      statusMsg.textContent = problems.join(' ');

      // 균형
      const pStar = (denom!==0)? (TD - TS)/denom : NaN;
      const qStar = (denom!==0)? (SD*pStar + TD) : NaN;

      // 축 재설정
      if(fit && [SD,TD,SS,TS].every(Number.isFinite)){ fitAxes(SD,TD,SS,TS); }
      sdcChart.options.scales.x.max = BASE_QMAX;
      sdcChart.options.scales.y.max = BASE_PMAX;

      // 전체 라인
      const demandAll = sampleLineQP(P=>SD*P + TD, BASE_PMAX);
      const supplyAll = sampleLineQP(P=>SS*P + TS, BASE_PMAX);

      // 잉여 및 보조요소
      let csBase=[], csSeg=[], psBase=[], psSeg=[], eqPt=[], vProj=[], hProj=[];
      let CS=NaN, PS=NaN;

      const valid = [pStar,qStar,SD,SS].every(Number.isFinite) && (pStar>=0) && (qStar>=0);

      if(valid){
        const Pd = (Q)=> (SD!==0)? ((Q - TD)/SD) : NaN;  // 수요의 P(Q)
        const Ps = (Q)=> (SS!==0)? ((Q - TS)/SS) : NaN;  // 공급의 P(Q)

        csBase = [{x:0, y:pStar}, {x:qStar, y:pStar}];
        psBase = csBase.slice();

        csSeg = segment_PofQ(Pd, qStar);
        psSeg = segment_PofQ(Ps, qStar);

        eqPt = [{x:qStar, y:pStar}];
        vProj = [{x:qStar, y:0}, {x:qStar, y:pStar}];
        hProj = [{x:0, y:pStar}, {x:qStar, y:pStar}];

        const Pchoke = (SD!==0)? (-TD/SD) : NaN;
        const Pmin   = (SS!==0)? (-TS/SS) : NaN;
        CS = 0.5 * Math.max(0, (Pchoke - pStar)) * qStar;
        PS = 0.5 * Math.max(0, (pStar - Pmin)) * qStar;
      }

      // 차트 반영
      const ds = sdcChart.data.datasets;
      ds[0].data = demandAll;
      ds[1].data = supplyAll;

      ds[2].data = csBase;
      ds[3].data = csSeg;

      ds[4].data = psBase;
      ds[5].data = psSeg;

      ds[6].data = eqPt;
      ds[7].data = vProj;
      ds[8].data = hProj;

      sdcChart.update('none');

      // 숫자 반영
      pStarEl.textContent = fmt(pStar,2);
      qStarEl.textContent = fmt(qStar,2);
      csValEl.textContent = fmt(CS,2);
      psValEl.textContent = fmt(PS,2);
    }

    // 바인딩
    [sd,td,ss,ts].forEach(inp=>{
      inp.addEventListener('input', ()=>recomputeAndDraw());
      inp.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); recomputeAndDraw(); } });
    });
    refitBtn.addEventListener('click', ()=>recomputeAndDraw({fit:true}));

    // 초기화
    document.addEventListener('DOMContentLoaded', ()=>{
      loadColors();
      // 최초 파싱 후 축/차트 생성
      const p = params();
      if([p.sd,p.td,p.ss,p.ts].every(Number.isFinite)) fitAxes(p.sd,p.td,p.ss,p.ts);
      createChart();
      recomputeAndDraw({fit:true});
      const y = document.querySelector('#year'); if(y) y.textContent = new Date().getFullYear();
    });
  </script>
</body>
</html>
